<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2022/09/02/Mysql%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/09/02/Mysql%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="MYSQL的索引类型"><a href="#MYSQL的索引类型" class="headerlink" title="MYSQL的索引类型"></a>MYSQL的索引类型</h2><ul><li>普通索引 INDEX</li><li>唯一索引 UNIQUE</li><li>主键索引</li><li>组合索引</li><li>全文索引</li></ul><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>普通索引是最基本的索引，没用任何的限制。在创建的时候可以指定索引的长度。length 为可选参数，表示索引的长度（索引长度表示数组的元素个数），只有字符串类型的字段才能指定索引长度，如果是 BLOB 和 TEXT 类型，必须指定 length。</p><p>创建索引的时候需要注意：</p><ul><li>如果指定单列索引长度，length 必须小于这个字段所允许的最大字符个数。</li><li>查询索引：SHOW INDEX FROM table_name</li></ul><h3 id="直接创建索引"><a href="#直接创建索引" class="headerlink" title="直接创建索引"></a>直接创建索引</h3><p>CREATE INDEX index_name ON table(column(length))<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">给 student 表中的 name 创建一个索引，索引名称为 stu_name_index </span><br><span class="line">create index stu_name_index ON student(name)</span><br></pre></td></tr></table></figure></p><h3 id="修改表添加索引"><a href="#修改表添加索引" class="headerlink" title="修改表添加索引"></a>修改表添加索引</h3><p>ALTER TABLE table_name ADD INDEX index_name (column(length))<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">修改 student 表，为 class 列添加索引，索引名为 student_class_index</span><br><span class="line">alter table student add index student_class_index(class)</span><br></pre></td></tr></table></figure></p><h3 id="创建表时指定索引列"><a href="#创建表时指定索引列" class="headerlink" title="创建表时指定索引列"></a>创建表时指定索引列</h3><p>CREATE TABLE <code>table</code> (COLUMN TYPE ,PRIMARY KEY (<code>id</code>),INDEX index_name (column(length)))<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">创建 student 表，包含 student_id,name,class 列，同时为 name 列创建索引。索引名为 student_name_index</span><br><span class="line">create table student(student_id int primary key auto_increment,name varchar(30),class varchar(50),index student_name_index(name))</span><br></pre></td></tr></table></figure></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>DROP INDEX index_name ON table<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">删除 student 表中索引名为 student_class_index 的索引</span><br><span class="line">drop index student_class_index on student</span><br></pre></td></tr></table></figure></p><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>唯一索引与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。</p><p>同上 ↑</p><h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。<br>我们只需要给表添加主键约束,MySQL就会自动给列添加主键索引;</p><h3 id="添加主键索引"><a href="#添加主键索引" class="headerlink" title="添加主键索引"></a>添加主键索引</h3><p>ALTER TABLE 表名 ADD PRIMARY KEY(列名)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">修改 student 表为 student_id 添加主键索引</span><br><span class="line">alter table student add primary key(student_id)</span><br></pre></td></tr></table></figure></p><h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>组合索引是指使用多个字段创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用(最左前缀原则)。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>就是最左优先。<br>如：我们使用表中的 name，address，salary 创建组合索引，那么想要组合索引生效，<br>我们只能使用如下组合：<br>name/address/salary<br>name/address<br>name/<br>如果使用 addrees/salary 或者是 salary 则索引不会生效。</p><p>ALTER TABLE table_name ADD INDEX index_name (column(length),column(length))<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">修改 student 表，为 name，class 列创建组合索引</span><br><span class="line">alter table student add index student_index_n_c(name,class)</span><br></pre></td></tr></table></figure></p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>全文索引(FULLTEXT INDEX)主要用来查找文本中的关键字，而不是直接与索引中的值相比较。FULLTEXT 索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的 where<br>语句的参数匹配。<br>FULLTEXT 索引配合 match against 操作使用，而不是一般的 where 语句加 like。<br>全文索引可以从 CHAR、VARCHAR 或 TEXT 列中作为 CREATE TABLE 语句的一部分被创建，或是随后使用 ALTER TABLE 添加。不过切记对于大容量的数据表，生成全文索<br>引是一个非常消耗时间非常消耗硬盘空间的做法。</p><h3 id="修改添加全文索引"><a href="#修改添加全文索引" class="headerlink" title="修改添加全文索引"></a>修改添加全文索引</h3><p>ALTER TABLE table_name ADD FULLTEXT index_name(clumn_name)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例一</span><br><span class="line">修改 student 表添加 content 列类型为 TEXT</span><br><span class="line">alter table student add COLUMN content text;</span><br><span class="line"></span><br><span class="line">示例二</span><br><span class="line">修改 student 表，为 content 列创建全文索引</span><br><span class="line">alter table student add fulltext student_content_fullindex(content)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
          <category> 索引 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word导出</title>
      <link href="/2022/07/25/word%E5%AF%BC%E5%87%BA/"/>
      <url>/2022/07/25/word%E5%AF%BC%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>最近接到一个新的需求，要把所有数据在一个模板内全部展示，而且是要支持分页的<br>在这之前所做的都是一个模板之展示一页，怎么做呢？？？</p><span id="more"></span><p><strong>Look down</strong></p><p>先看下效果图</p><p><img src="https://liang-git.oss-cn-beijing.aliyuncs.com/hexo/word%E5%88%86%E9%A1%B5.png" alt=""></p><h2 id="引入pom依赖"><a href="#引入pom依赖" class="headerlink" title="引入pom依赖"></a>引入pom依赖</h2><p>依赖是使用的EasyPoi，它可以很方便的同意一个word模板进行填充生成我们想要的word文档。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--easypoi依赖，excel导入导出--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.afterturn&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;easypoi-base&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="实现word导出"><a href="#实现word导出" class="headerlink" title="实现word导出"></a>实现word导出</h2><h3 id="先定义word模板"><a href="#先定义word模板" class="headerlink" title="先定义word模板"></a>先定义word模板</h3><p><img src="https://liang-git.oss-cn-beijing.aliyuncs.com/hexo/word%E5%88%86%E9%A1%B5%E6%A8%A1%E6%9D%BF.png" alt=""></p><p>模板里包含正常的标签和需要遍历的标签，fe遍历应该是使用最广的遍历了，用来解决遍历下面需要的数据。</p><p><strong>fe写法</strong></p><p>语法：fe标志 冒号 list数据 单个元素数据（默认t，可以省略不写）</p><p>参考：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;$fe: list t t.dataTime&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>list对应于代码中传入 <strong>exportWord07(String url, Map<String, Object> map)</strong> 的map中还有list的key.</p><h3 id="定义Controller"><a href="#定义Controller" class="headerlink" title="定义Controller"></a>定义Controller</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiOperation(&quot;Word文档导出&quot;)</span><br><span class="line">@PostMapping(&quot;/wordExport&quot;)</span><br><span class="line">public void wordExport(@ApiParam(value = &quot;库存批次主键&quot;,required = true)</span><br><span class="line">                    @RequestParam(value = &quot;inventoryId&quot;) Long inventoryId,</span><br><span class="line">                    HttpServletRequest request, HttpServletResponse response)&#123;</span><br><span class="line">    inventoryBatchService.wordExport(inventoryId, request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法（service）"><a href="#核心方法（service）" class="headerlink" title="核心方法（service）"></a>核心方法（service）</h3><h4 id="组装数据"><a href="#组装数据" class="headerlink" title="组装数据"></a>组装数据</h4><p>简单来说就是map中放list，list中放map<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; mapList = new HashMap&lt;&gt;();</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; maps = new ArrayList&lt;&gt;();</span><br><span class="line">mapList.put(&quot;list&quot;,maps);</span><br><span class="line">mapList.put(&quot;projectName&quot;,&quot;123&quot;);</span><br><span class="line">mapList.put(&quot;oneNumber&quot;,&quot;123&quot;);</span><br><span class="line">mapList.put(&quot;oneProject&quot;,&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">ExportWordUtil.exportWord();</span><br></pre></td></tr></table></figure></p><h4 id="util"><a href="#util" class="headerlink" title="util"></a>util</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExportWordUtil&#123;</span><br><span class="line">   private WordUtil() &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Utility class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final String WORD_DOXC = &quot;docx&quot;;</span><br><span class="line">    private static final String MISE = &quot;msie&quot;;</span><br><span class="line">    private static final String LIKE_GECKO = &quot;like gecko&quot;;</span><br><span class="line">    private static final String MOZILLA = &quot;Mozilla&quot;;</span><br><span class="line">    private static final String PATH_JOINER = &quot;/&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取文档中表格需要分页填充的每页条数</span><br><span class="line">     * @param in 文件流</span><br><span class="line">     * @param filePath 模板路径</span><br><span class="line">     */</span><br><span class="line">    public static long wordTableCount(InputStream in, String filePath) &#123;</span><br><span class="line">        long count = 0;</span><br><span class="line">        try&#123;</span><br><span class="line">            //载入文档 如果是office2007  docx格式</span><br><span class="line">            if(filePath.toLowerCase().endsWith(WORD_DOXC))&#123;</span><br><span class="line">                //word 2007 图片不会被读取， 表格中的数据会被放在字符串的最后</span><br><span class="line">                //得到word文档的信息</span><br><span class="line">                XWPFDocument xwpf = new XWPFDocument(in);</span><br><span class="line">                List&lt;XWPFTable&gt; tables = xwpf.getTables();</span><br><span class="line">                // get(index) index+1 !&gt; tables</span><br><span class="line">                XWPFTable table2 = tables.get(0);</span><br><span class="line">                // word文档中表格总行数</span><br><span class="line">                List&lt;XWPFTableRow&gt; list = table2.getRows();</span><br><span class="line">                String[] split = table2.getText().split(&quot;\n&quot;);</span><br><span class="line">                // word文档中有数据的行数</span><br><span class="line">                List&lt;String&gt; list2 = Arrays.asList(split);</span><br><span class="line">                count = list.size() - list2.size();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                InputStream inputStream = new FileInputStream(filePath);</span><br><span class="line">                HWPFDocument doc = new HWPFDocument(inputStream);</span><br><span class="line">                Range range = doc.getRange();</span><br><span class="line">                //遍历range范围内的table。</span><br><span class="line">                TableIterator tableInter = new TableIterator(range);</span><br><span class="line">                Table table;</span><br><span class="line">                TableRow row;</span><br><span class="line">                List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                while (tableInter.hasNext()) &#123;</span><br><span class="line">                    table = tableInter.next();</span><br><span class="line">                    int rowNum = table.numRows();</span><br><span class="line">                    for (int j=0; j&lt;rowNum; j++) &#123;</span><br><span class="line">                        row = table.getRow(j);</span><br><span class="line">                        int cellNum = row.numCells();</span><br><span class="line">                        list.add(cellNum);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class="line">                if (max.isPresent())&#123;</span><br><span class="line">                    int asInt = max.get();</span><br><span class="line">                    if (asInt &gt;= 0)&#123;</span><br><span class="line">                        // -1 是为了排除掉表头</span><br><span class="line">                        count = list.stream().filter(a -&gt; a.equals(asInt)).count() -1 ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;catch(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 导出word</span><br><span class="line">     * @param templatePath word模板地址</span><br><span class="line">     * @param temDir 生成临时文件存放地址</span><br><span class="line">     * @param fileName 文件名</span><br><span class="line">     * @param maps 替换的参数</span><br><span class="line">     * @param request HttpServletRequest</span><br><span class="line">     * @param response HttpServletResponse</span><br><span class="line">     */</span><br><span class="line">    public static void exportWord(File templatePath, String temDir, String fileName, Map&lt;String, Object&gt; maps, HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        Assert.notNull(templatePath,&quot;word模板路径不能为空！&quot;);</span><br><span class="line">        Assert.notNull(temDir,&quot;word导出路径不能为空！&quot;);</span><br><span class="line">        Assert.notNull(fileName, &quot;导出文件名称不能为空！&quot;);</span><br><span class="line">        Assert.isTrue(fileName.endsWith(&quot;.docx&quot;),&quot;word导出请使用docx格式！&quot;);</span><br><span class="line">        if (!temDir.endsWith(PATH_JOINER))&#123;</span><br><span class="line">            temDir = temDir + File.separator;</span><br><span class="line">        &#125;</span><br><span class="line">        File dir = new File(temDir);</span><br><span class="line">        if (!dir.exists()) &#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String userAgent = request.getHeader(&quot;user-agent&quot;).toLowerCase();</span><br><span class="line">            if (userAgent.contains(MISE) || userAgent.contains(LIKE_GECKO)) &#123;</span><br><span class="line">                fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fileName = new String(fileName.getBytes(StandardCharsets.UTF_8), StandardCharsets.ISO_8859_1);</span><br><span class="line">            &#125;</span><br><span class="line">            XWPFDocument doc = WordExportUtil.exportWord07(String.valueOf(templatePath), maps);</span><br><span class="line">            String tmpPath = temDir + fileName;</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(tmpPath);</span><br><span class="line">            doc.write(fos);</span><br><span class="line">            response.setContentType(&quot;multipart/form-data&quot;);</span><br><span class="line">            response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">            // 设置文件名</span><br><span class="line">            fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;);</span><br><span class="line">            response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);</span><br><span class="line">            //设置是否在浏览器内直接下载文件</span><br><span class="line">            OutputStream out = response.getOutputStream();</span><br><span class="line">            doc.write(out);</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 导出word保存本地</span><br><span class="line">     * @param templatePath word模板地址</span><br><span class="line">     * @param temDir 生成临时文件存放地址</span><br><span class="line">     * @param fileName 文件名</span><br><span class="line">     * @param maps 替换的参数</span><br><span class="line">     * @param request HttpServletRequest</span><br><span class="line">     * @return String  文件路径</span><br><span class="line">     */</span><br><span class="line">    public static String exportWordPath(File templatePath, String temDir, String fileName, Map&lt;String, Object&gt; maps, HttpServletRequest request) &#123;</span><br><span class="line">        Assert.notNull(templatePath,&quot;word模板路径不能为空！&quot;);</span><br><span class="line">        Assert.notNull(temDir,&quot;word导出路径不能为空！&quot;);</span><br><span class="line">        Assert.notNull(fileName, &quot;导出文件名称不能为空！&quot;);</span><br><span class="line">        Assert.isTrue(fileName.endsWith(&quot;.docx&quot;),&quot;word导出请使用docx格式！&quot;);</span><br><span class="line">        if (!temDir.endsWith(PATH_JOINER))&#123;</span><br><span class="line">            temDir = temDir + File.separator;</span><br><span class="line">        &#125;</span><br><span class="line">        File dir = new File(temDir);</span><br><span class="line">        if (!dir.exists()) &#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String userAgent = request.getHeader(&quot;user-agent&quot;).toLowerCase();</span><br><span class="line">            if (userAgent.contains(MISE) || userAgent.contains(LIKE_GECKO)) &#123;</span><br><span class="line">                fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fileName = new String(fileName.getBytes(StandardCharsets.UTF_8), StandardCharsets.ISO_8859_1);</span><br><span class="line">            &#125;</span><br><span class="line">            XWPFDocument doc = WordExportUtil.exportWord07(String.valueOf(templatePath), maps);</span><br><span class="line">            String tmpPath = temDir + fileName;</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(tmpPath);</span><br><span class="line">            doc.write(fos);</span><br><span class="line">            fos.close();</span><br><span class="line">            return tmpPath;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 导出word生成字节</span><br><span class="line">     * @param templatePath word模板地址</span><br><span class="line">     * @param maps 替换的参数</span><br><span class="line">     * @return byte[]  文件字节</span><br><span class="line">     */</span><br><span class="line">    public static byte[] exportWordByte(File templatePath, Map&lt;String, Object&gt; maps) &#123;</span><br><span class="line">        Assert.notNull(templatePath,&quot;word模板路径不能为空！&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            XWPFDocument doc = WordExportUtil.exportWord07(String.valueOf(templatePath), maps);</span><br><span class="line">            ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">            doc.write(out);</span><br><span class="line">            out.close();</span><br><span class="line">            doc.close();</span><br><span class="line">            return out.toByteArray();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return new byte[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * word文档分页导出</span><br><span class="line">     * @param templatePath 模板file</span><br><span class="line">     * @param temDir 导出路径</span><br><span class="line">     * @param fileName 文件名称</span><br><span class="line">     * @param maps 导出数据</span><br><span class="line">     * @param mapKey  maps中的list的key</span><br><span class="line">     * @param index  每页条数</span><br><span class="line">     * @param request  request</span><br><span class="line">     * @return String  文件所在路径</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static String exportPageWord(File templatePath, String temDir, String fileName, Map&lt;String, Object&gt; maps, HttpServletRequest request,</span><br><span class="line">                                     String mapKey, Integer index) &#123;</span><br><span class="line">        Assert.notNull(templatePath,&quot;word模板路径不能为空！&quot;);</span><br><span class="line">        Assert.notNull(index,&quot;分页条数不能为空！&quot;);</span><br><span class="line">        Assert.notNull(temDir,&quot;word导出路径不能为空！&quot;);</span><br><span class="line">        Assert.notNull(fileName, &quot;导出文件名称不能为空！&quot;);</span><br><span class="line">        Assert.isTrue(fileName.endsWith(&quot;.docx&quot;),&quot;word导出请使用docx格式！&quot;);</span><br><span class="line">        if (!temDir.endsWith(PATH_JOINER))&#123;</span><br><span class="line">            temDir = temDir + File.separator;</span><br><span class="line">        &#125;</span><br><span class="line">        File dir = new File(temDir);</span><br><span class="line">        if (!dir.exists()) &#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String userAgent = request.getHeader(&quot;user-agent&quot;).toLowerCase();</span><br><span class="line">            if (userAgent.contains(MISE) || userAgent.contains(LIKE_GECKO)) &#123;</span><br><span class="line">                fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;);</span><br><span class="line">            &#125; else if(StringUtils.contains(userAgent, MOZILLA))&#123;</span><br><span class="line">                //google,火狐浏览器</span><br><span class="line">                fileName = new String(fileName.getBytes(), &quot;ISO8859-1&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //其他浏览器</span><br><span class="line">                fileName = URLEncoder.encode(fileName,&quot;UTF8&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;XWPFDocument&gt; wordList = new ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; mapList = (List&lt;Map&lt;String, Object&gt;&gt;) maps.get(mapKey);</span><br><span class="line">            int size = mapList.size();</span><br><span class="line">            // 判断是否满足分页要求</span><br><span class="line">            if (size &gt;= index)&#123;</span><br><span class="line">                // 获取分页后的总页数</span><br><span class="line">                int pages = getPages(mapList, index);</span><br><span class="line">                for (int i = 1; i &lt;= pages; i++) &#123;</span><br><span class="line">                    // 分页</span><br><span class="line">                    List&lt;Map&lt;String, Object&gt;&gt; list = getListPage(i, index, mapList);</span><br><span class="line">                    // list.size()不满足 index 以空补全</span><br><span class="line">                    // 替换map中相同key的值</span><br><span class="line">                    maps.put(mapKey, list);</span><br><span class="line">                    // 生成word</span><br><span class="line">                    XWPFDocument doc = WordExportUtil.exportWord07(templatePath.toString(), maps);</span><br><span class="line">                    wordList.add(doc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                maps.put(mapKey, mapList);</span><br><span class="line">                XWPFDocument doc = WordExportUtil.exportWord07(String.valueOf(templatePath), maps);</span><br><span class="line">                wordList.add(doc);</span><br><span class="line">            &#125;</span><br><span class="line">            XWPFDocument word = mergeWord(wordList);</span><br><span class="line">            String tmpPath = temDir + fileName;</span><br><span class="line">            File file = new File(tmpPath);</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">            word.write(fos);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return temDir+fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取生成的单个word  XWPFDocument</span><br><span class="line">     * @param templatePath word模板地址</span><br><span class="line">     * @param maps 替换的参数</span><br><span class="line">     * @return  XWPFDocument</span><br><span class="line">     */</span><br><span class="line">    public static XWPFDocument getWordDocument(File templatePath, Map&lt;String, Object&gt; maps) &#123;</span><br><span class="line">        Assert.notNull(templatePath,&quot;word模板路径不能为空！&quot;);</span><br><span class="line">        XWPFDocument xwpfDocument = new XWPFDocument();</span><br><span class="line">        try &#123;</span><br><span class="line">            xwpfDocument =  WordExportUtil.exportWord07(String.valueOf(templatePath), maps);</span><br><span class="line">            return xwpfDocument;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return xwpfDocument;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * word文件合并</span><br><span class="line">     * @param wordList  要合并的word</span><br><span class="line">     * @return XWPFDocument</span><br><span class="line">     */</span><br><span class="line">    public static XWPFDocument mergeWord(List&lt;XWPFDocument&gt; wordList) &#123;</span><br><span class="line">        if (!CollectionUtils.isEmpty(wordList)) &#123;</span><br><span class="line">            XWPFDocument doc = wordList.get(0);</span><br><span class="line">            int size = wordList.size();</span><br><span class="line">            if (size &gt; 1) &#123;</span><br><span class="line">                doc.createParagraph().setPageBreak(true);</span><br><span class="line">                for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">                    // 从第二个word开始合并</span><br><span class="line">                    XWPFDocument nextPageDoc = wordList.get(i);</span><br><span class="line">                    // 最后一页不需要设置分页符</span><br><span class="line">                    if (i != (size-1)) &#123;</span><br><span class="line">                        nextPageDoc.createParagraph().setPageBreak(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                    appendBody(doc, nextPageDoc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return doc;</span><br><span class="line">        &#125;</span><br><span class="line">        return new XWPFDocument();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void appendBody(XWPFDocument src, XWPFDocument append) &#123;</span><br><span class="line">        CTBody src1Body = src.getDocument().getBody();</span><br><span class="line">        CTBody src2Body = append.getDocument().getBody();</span><br><span class="line">        List&lt;XWPFPictureData&gt; allPictures = append.getAllPictures();</span><br><span class="line">        // 记录图片合并前及合并后的ID</span><br><span class="line">        Map&lt;String,String&gt; map = new HashMap&lt;&gt;(4);</span><br><span class="line">        for (XWPFPictureData picture : allPictures) &#123;</span><br><span class="line">            String before = append.getRelationId(picture);</span><br><span class="line">            //将原文档中的图片加入到目标文档中</span><br><span class="line">            String after = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                after = src.addPictureData(picture.getData(), Document.PICTURE_TYPE_PNG);</span><br><span class="line">            &#125; catch (InvalidFormatException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(before, after);</span><br><span class="line">        &#125;</span><br><span class="line">        appendBody(src1Body, src2Body,map);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void appendBody(CTBody src, CTBody append, Map&lt;String,String&gt; map) &#123;</span><br><span class="line">        XmlOptions optionsOuter = new XmlOptions();</span><br><span class="line">        optionsOuter.setSaveOuter();</span><br><span class="line">        String appendString = append.xmlText(optionsOuter);</span><br><span class="line">        String srcString = src.xmlText();</span><br><span class="line">        String prefix = srcString.substring(0,srcString.indexOf(&quot;&gt;&quot;)+1);</span><br><span class="line">        String mainPart = srcString.substring(srcString.indexOf(&quot;&gt;&quot;)+1,srcString.lastIndexOf(&quot;&lt;&quot;));</span><br><span class="line">        String sufix = srcString.substring( srcString.lastIndexOf(&quot;&lt;&quot;) );</span><br><span class="line">        String addPart = appendString.substring(appendString.indexOf(&quot;&gt;&quot;) + 1, appendString.lastIndexOf(&quot;&lt;&quot;));</span><br><span class="line">        if (map != null &amp;&amp; !map.isEmpty()) &#123;</span><br><span class="line">            //对xml字符串中图片ID进行替换</span><br><span class="line">            for (Map.Entry&lt;String, String&gt; set : map.entrySet()) &#123;</span><br><span class="line">                addPart = addPart.replace(set.getKey(), set.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将两个文档的xml内容进行拼接</span><br><span class="line">        CTBody makeBody = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            makeBody = CTBody.Factory.parse(prefix+mainPart+addPart+sufix);</span><br><span class="line">        &#125; catch (XmlException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        src.set(makeBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * list分页展示</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;Map&lt;String, Object&gt;&gt; getListPage(int page, int pageSize, List&lt;Map&lt;String, Object&gt;&gt; list) &#123;</span><br><span class="line">        int totalCount = list.size();</span><br><span class="line">        page = page - 1;</span><br><span class="line">        int fromIndex = page * pageSize;</span><br><span class="line">        //分页不能大于总数</span><br><span class="line">        int toIndex = ((page + 1) * pageSize);</span><br><span class="line">        if (toIndex &gt; totalCount) &#123;</span><br><span class="line">            toIndex = totalCount;</span><br><span class="line">        &#125;</span><br><span class="line">        return list.subList(fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回总页数</span><br><span class="line">     */</span><br><span class="line">    public static int getPages(List&lt;Map&lt;String, Object&gt;&gt; obj, Integer pageSize) &#123;</span><br><span class="line">        int count = obj.size() / pageSize;</span><br><span class="line">        if (obj.isEmpty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj.size() &lt;= pageSize) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (count % pageSize == 0) &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return count + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param files  文件路径</span><br><span class="line">     * @param name  压缩包名称</span><br><span class="line">     * @return void</span><br><span class="line">     * 压缩文件</span><br><span class="line">     */</span><br><span class="line">    public static void writeZip(List&lt;String&gt; files, String name) throws IOException &#123;</span><br><span class="line">        ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        if (null != servletRequestAttributes)&#123;</span><br><span class="line">            HttpServletResponse response = servletRequestAttributes.getResponse();</span><br><span class="line">            SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span><br><span class="line">            String format = dateFormat.format(new Date());</span><br><span class="line">            String fileName = name + format + &quot;.zip&quot;;</span><br><span class="line">            assert response != null;</span><br><span class="line">            response.reset();</span><br><span class="line">            response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">            response.setContentType(&quot;application/zip;  charset=utf-8&quot;);</span><br><span class="line">            response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(fileName,&quot;UTF-8&quot;));</span><br><span class="line"></span><br><span class="line">            OutputStream os = response.getOutputStream();</span><br><span class="line">            ZipOutputStream zos = new ZipOutputStream(os);</span><br><span class="line">            BufferedInputStream bis = null;</span><br><span class="line">            byte[] buf = new byte[2048];</span><br><span class="line">            int len;</span><br><span class="line">            for (int i = 0; i &lt; files.size(); i++) &#123;</span><br><span class="line">                File file = new File(files.get(i));</span><br><span class="line">                if (!file.isFile()) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ZipEntry ze = new ZipEntry(file.getName());</span><br><span class="line">                zos.putNextEntry(ze);</span><br><span class="line">                bis = new BufferedInputStream(new FileInputStream(file));</span><br><span class="line">                while ((len = bis.read(buf)) &gt; 0) &#123;</span><br><span class="line">                    zos.write(buf, 0, len);</span><br><span class="line">                &#125;</span><br><span class="line">                zos.closeEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            zos.closeEntry();</span><br><span class="line">            zos.close();</span><br><span class="line">            if(bis!=null)&#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> word </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流</title>
      <link href="/2022/06/27/Stream%E6%B5%81/"/>
      <url>/2022/06/27/Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。</p><span id="more"></span><h2 id="流的创建方法"><a href="#流的创建方法" class="headerlink" title="流的创建方法"></a>流的创建方法</h2><ul><li>Collection下的stream()和parallelStream()方法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();  //顺序流</span><br><span class="line">Stream&lt;String&gt; stringStream = list.parallelStream(); //并行流</span><br><span class="line"></span><br><span class="line">// parallelStream用在多线程并发时，而stream是单线程</span><br></pre></td></tr></table></figure><ul><li>Arrays中的stream()方法，将数组转成流 </li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer[] nums = new Integer[]&#123;9,5,2,8&#125;;</span><br><span class="line">Stream&lt;Integer&gt; Integerstream = Arrays.stream(nums);</span><br></pre></td></tr></table></figure><ul><li>Stream中的静态方法：of()、iterate()、generate()</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; TestStream = Stream.of(1,2,3,4);</span><br><span class="line">//iterate()、generate()方法可以创建无限流，可以通过limit()方法来限制数量。</span><br><span class="line">Stream&lt;Integer&gt; TestStream2 = Stream.iterate(0,x-&gt;x+2);</span><br><span class="line">Stream&lt;Integer&gt; TestStream3 = Stream.generate(()-&gt; new Random().nextInt(10));</span><br><span class="line">Stream&lt;Integer&gt; TestStream4 = Stream.iterate(0,x-&gt;x+2).limit(10);</span><br></pre></td></tr></table></figure><ul><li>BufferedReader.lines() 方法，将每行内容转成流</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader reader = new BufferedReader(new FileReader(&quot;D:\\test_stream.txt&quot;));</span><br><span class="line">Stream&lt;String&gt; lineStream = reader.lines();</span><br><span class="line">//上面可以写成一行</span><br><span class="line">Stream&lt;String&gt; lineStream2 = new BufferedReader(new FileReader(&quot;D:\\test_stream.txt&quot;)).lines();</span><br></pre></td></tr></table></figure><ul><li>Pattern.splitAsStream() 方法，将字符串分隔成流</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(&quot;,&quot;);</span><br><span class="line">Stream&lt;String&gt; stringStream2 = pattern.splitAsStream(&quot;a,b,c,d&quot;);</span><br></pre></td></tr></table></figure><h2 id="流的中间操作"><a href="#流的中间操作" class="headerlink" title="流的中间操作"></a>流的中间操作</h2><h3 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h3><ul>    <li>filter:过滤流中的某个元素</li>    <li>limit(n):获取n个元素，限制获取元素的个数</li>    <li>skip(n):跳过n元素，配合limit(n)可实现分页</li>    <li>distinct:通过流中的hashCode()和equals()去除重复的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(6,6,6,12,22,12,213,111,7,9,10);</span><br><span class="line">Stream&lt;Integer&gt; streamFilter = stream.filter(item -&gt; item &gt; 10) // 12 22 12 213 111</span><br><span class="line">        .distinct() //12 22 213 111</span><br><span class="line">        .skip(2) //213 111</span><br><span class="line">        .limit(1);//213</span><br><span class="line">streamFilter.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><ul>    <li>map:接收一个函数作为参数，(常为lambda表达式)该函数会被应用到每个元素上，并将其映射成一个新的元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;String&quot;,&quot;f,g,h&quot;);</span><br><span class="line">Stream&lt;String&gt; stringStream = list.stream().map(s -&gt; s.replaceAll(&quot;,&quot;, &quot;&quot;));//String fgh</span><br><span class="line">//flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</span><br><span class="line">Stream&lt;String&gt; stringStream2 = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">    String[] split = s.split(&quot;,&quot;);</span><br><span class="line">    Stream&lt;String&gt; testStream = Arrays.stream(split);</span><br><span class="line">    return testStream;</span><br><span class="line">&#125;);//String f g h</span><br><span class="line">stringStream2.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>sorted()：自然排序,流中元素需实现Comparable接口</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> List&lt;String&gt; list = Arrays.asList(&quot;tt&quot;,&quot;er&quot;,&quot;Ad&quot;);</span><br><span class="line"> list.stream().sorted().forEach(System.out::println);//Ad er tt</span><br><span class="line"> //这里String类已经实现了Comparable接口</span><br><span class="line">Person p1 = new Person(&quot;zhangsan&quot;,26);</span><br><span class="line"> Person p2 = new Person(&quot;zhangsan&quot;,22);</span><br><span class="line"> Person p3 = new Person(&quot;wangwu&quot;,23);</span><br><span class="line"> List&lt;Person&gt; list = Arrays.asList(p1,p2,p3);</span><br><span class="line"> //自定义Comparator排序器 自定义排序：先按姓名升序，姓名相同则按年龄升序</span><br><span class="line"> list.stream().sorted((o1,o2)-&gt;&#123;</span><br><span class="line">     if(o1.getName().equals(o2.getName()))&#123;</span><br><span class="line">         return o1.getAge()-o2.getAge();</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">         return o1.getName().compareTo(o2.getName());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><ul><li>peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person p1 = new Person(&quot;zhangsan&quot;,26);</span><br><span class="line">Person p2 = new Person(&quot;lisi&quot;,22);</span><br><span class="line">Person p3 = new Person(&quot;wangwu&quot;,23);</span><br><span class="line">List&lt;Person&gt; list = Arrays.asList(p1,p2,p3);</span><br><span class="line">list.stream().map(item-&gt;&#123;</span><br><span class="line">    item.setAge(100);</span><br><span class="line">    return item;</span><br><span class="line">&#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">// 使用peek</span><br><span class="line">Person p1 = new Person(&quot;zhangsan&quot;,26);</span><br><span class="line">Person p2 = new Person(&quot;lisi&quot;,22);</span><br><span class="line">Person p3 = new Person(&quot;wangwu&quot;,23);</span><br><span class="line">List&lt;Person&gt; list = Arrays.asList(p1,p2,p3);</span><br><span class="line">list.stream().peek(item-&gt;item.setAge(100)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="流的终止操作"><a href="#流的终止操作" class="headerlink" title="流的终止操作"></a>流的终止操作</h2><h3 id="匹配、聚合操作"><a href="#匹配、聚合操作" class="headerlink" title="匹配、聚合操作"></a>匹配、聚合操作</h3><ul>    <li>allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false</li>    <li>noneMatch：接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false</li>    <li>anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false</li>    <li>findFirst：返回流中第一个元素</li>    <li>findAny：返回流中的任意元素</li>    <li>count：返回流中元素的总个数</li>    <li>max：返回流中元素最大值</li>    <li>min：返回流中元素最小值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);  </span><br><span class="line"></span><br><span class="line">boolean allMatch = list.stream().allMatch(e -&gt; e &gt; 10); //false</span><br><span class="line">boolean noneMatch = list.stream().noneMatch(e -&gt; e &gt; 10); //true</span><br><span class="line">boolean anyMatch = list.stream().anyMatch(e -&gt; e &gt; 4); //true </span><br><span class="line"></span><br><span class="line">Integer findFirst = list.stream().findFirst().get(); //1</span><br><span class="line">Integer findAny = list.stream().findAny().get(); //1 </span><br><span class="line"></span><br><span class="line">long count = list.stream().count(); //5</span><br><span class="line">Integer max = list.stream().max(Integer::compareTo).get(); //5</span><br><span class="line">Integer min = list.stream().min(Integer::compareTo).get(); //1　</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stream流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合操作</title>
      <link href="/2022/06/27/%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/06/27/%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Map<Object, String><br>List<Map<Integer, Object>&gt;<br>List<Map<String, Object>&gt;</p><h2 id="更改map的key"><a href="#更改map的key" class="headerlink" title="更改map的key"></a>更改map的key</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过反射获取属性名称</span><br><span class="line">Map&lt;Object, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">ExcelWeldingData excelWeldingData = new ExcelWeldingData();</span><br><span class="line">Class&lt;? extends ExcelWeldingData&gt; dataClass = excelWeldingData.getClass();</span><br><span class="line">Field[] declaredFields = dataClass.getDeclaredFields();</span><br><span class="line">for (int i = 0; i &lt; declaredFields.length; i++) &#123;</span><br><span class="line">    map.put(i,declaredFields[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Map&lt;Integer, Object&gt;&gt; read = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;ExcelWeldingData&gt; resultList= new ArrayList&lt;&gt;();</span><br><span class="line">// 将原先key为 Integer 变为 String</span><br><span class="line">for (Map&lt;Integer, Object&gt; item : read) &#123;</span><br><span class="line">   Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">   item.forEach((k,v) -&gt;&#123;</span><br><span class="line">       // 此处name 为ExcelWeldingData对象中的属性名称</span><br><span class="line">       String name = map.get(k);</span><br><span class="line">       // key 为属性名称，value值不变</span><br><span class="line">       result.put(name,v);</span><br><span class="line">   &#125;);</span><br><span class="line">   ExcelWeldingData data = JSON.parseObject(JSON.toJSONString(result), ExcelWeldingData.class);</span><br><span class="line">   resultList.add(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="相同的数据-两个集合中的交集"><a href="#相同的数据-两个集合中的交集" class="headerlink" title="相同的数据(两个集合中的交集)"></a>相同的数据(两个集合中的交集)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;Object&gt; sameList(List&lt;Object&gt; oldArrayList, List&lt;Object&gt; newArrayList) &#123;</span><br><span class="line">    List&lt;Object&gt; resultList = newArrayList.stream()</span><br><span class="line">            .filter(item -&gt; oldArrayList.stream().map(e -&gt; e.getId())</span><br><span class="line">                    .collect(Collectors.toList()).contains(item.getId()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    return resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同的数据-两个集合中的差集"><a href="#不同的数据-两个集合中的差集" class="headerlink" title="不同的数据(两个集合中的差集)"></a>不同的数据(两个集合中的差集)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;Object&gt; diffList(List&lt;Object&gt; firstArrayList, List&lt;Object&gt; secondArrayList) &#123;</span><br><span class="line">    List&lt;Object&gt; resultList = firstArrayList.stream()</span><br><span class="line">            .filter(item -&gt; !secondArrayList.stream().map(e -&gt; e.getId()).collect(Collectors.toList()).contains(item.getId()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    return resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> map,list </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transactional事务</title>
      <link href="/2022/06/27/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/06/27/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Spring事务</p><span id="more"></span><h2 id="Spring事务的传播行为"><a href="#Spring事务的传播行为" class="headerlink" title="Spring事务的传播行为"></a>Spring事务的传播行为</h2><p><strong>TransactionDefinition</strong>定义中包括：</p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><h2 id="Spring事务的回滚机制"><a href="#Spring事务的回滚机制" class="headerlink" title="Spring事务的回滚机制"></a>Spring事务的回滚机制</h2><p>Spring的AOP声明事务管理默认是针对<strong>unchecked exception</strong>回滚。Spring事务边界是在调用业务方法之前 开始的，业务方法执行完毕之后执行<strong>commit or rollback</strong>(Spring默认取决于是否抛出runtimeException[运行时异常])。</p><p>如果方法中存在 <strong>try{}catch(Exception e){}</strong> 处理，那么try代码块就脱离了事务的管理，若要事务生效需要在catch中抛出<strong>throw new RuntimeException (“xxxxxx”)</strong>;</p><h2 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h2><ol><li><p>try{}catch(Exception e){}</p></li><li><p>调用本类中其他方法getExcelExport()时，那getExcelExport()方法上的@Transactional注解不会生效，加上也不会报错</p></li></ol><p>@Transactional注解的方法必须是公共方法，就是必须是public修饰符！！！</p><p>通过 <strong>AopContext.currentProxy()</strong> 获取到本类的代理对象，再去调用。因为这个是CGLIB实现，所以要开启AOP<br>在 <strong>springBoot</strong> 启动类上加上注解 <strong>@EnableAspectJAutoProxy(exposeProxy = true)</strong> 就可以<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 事务失效</span><br><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public Map&lt;String, Object&gt; excelImport(InputStream inputStream) &#123;</span><br><span class="line">    this.getExcelExport();</span><br><span class="line">&#125;</span><br><span class="line">@Transactional</span><br><span class="line">public String getExcelExport()&#123;</span><br><span class="line">    System.out.println(&quot;123&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>上面的片段事务在方法getExcelExport()中会失效。没有使用代理调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public Map&lt;String, Object&gt; excelImport(InputStream inputStream) &#123;</span><br><span class="line">    // 获取到本类的代理对象</span><br><span class="line">    WeldingTechnologyServiceImpl weldingTechnologyService = (WeldingTechnologyServiceImpl)AopContext.currentProxy ();  </span><br><span class="line">    weldingTechnologyService.getExcelExport();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getExcelExport()&#123;</span><br><span class="line">    System.out.println(&quot;123&quot;);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、就是@Transactional注解保证的是每个方法处在一个事务，如果有try一定在catch中抛出运行时异常。</p><p>2、方法必须是public修饰符。否则注解不会生效，但是加了注解也没啥毛病，不会报错，只是没卵用而已。</p><p>3、this.本方法的调用，被调用方法上注解是不生效的，因为无法再次进行切面增强。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射获取对象字段类型</title>
      <link href="/2022/06/21/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/06/21/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java反射的使用</p><span id="more"></span><h2 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h2><ol><li><p>getClass()</p><p>Object obj = new Object();<br>obj.getClass()</p></li><li><p>.class </p><p>Object.class</p></li><li><p>Class.forName()</p><p>Class.forName()方式适用于运行时动态获取Class对象，只需将类名作为forName方法的参数<br>Class.forName(“Object”);</p></li></ol><h2 id="获取对象中字段类型"><a href="#获取对象中字段类型" class="headerlink" title="获取对象中字段类型"></a>获取对象中字段类型</h2><p>列： WeldingData welding = new WeldingData();<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;? extends WeldingData&gt; dataClass = weldingData.getClass();</span><br><span class="line">Field[] fields = dataClass.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    // 用反射时访问私有变量</span><br><span class="line">    field.setAccessible(true);</span><br><span class="line">    // 取出字段类型  [class java.long.String]</span><br><span class="line">    field.getType();</span><br><span class="line">    // 取出字段名称</span><br><span class="line">    field.getName().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 对象操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jar包程序在Linux环境中读取静态资源</title>
      <link href="/2022/06/17/jar%E5%8C%85%E7%A8%8B%E5%BA%8F%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%AF%BB%E5%8F%96%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"/>
      <url>/2022/06/17/jar%E5%8C%85%E7%A8%8B%E5%BA%8F%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%AF%BB%E5%8F%96%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述</strong><br>将xlsx文件放到了resource目录下，在本地是可以读取到的，打成jar包之后访问不到<br><img src="https://liang-git.oss-cn-beijing.aliyuncs.com/hexo/jar.png" alt="错误信息" title="梁百川"></p><span id="more"></span><p><strong>解决办法</strong></p><p>1.在pom.xml文件中导入相关坐标和插件，保证不进行替换静态文件的属性，将资源打包进入jar包中<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--配置打包成jar包之后读取文件--&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">        &lt;!--不替换资源中的属性--&gt;</span><br><span class="line">        &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">        &lt;!--不替换资源中的属性--&gt;</span><br><span class="line">        &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>2.修改读取静态资源的方式</p><ul><li>使用ClassPathResource进行静态文件的读取，因为这个类的对象是用于获取class字节码文件路径的文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// resource下的文件路径</span><br><span class="line">ClassPathResource classPathResource = new ClassPathResource(&quot;static/123.xlsx&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">  InputStream inputStream = classPathResource.getInputStream();</span><br><span class="line">  MultipartFileUtil.inputStreamToFile(inputStream, new File(&quot;./焊接工艺数据库模板.xlsx&quot;));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中MultipartFileUtil.inputStreamToFile(),此方法是封装的工具类.工具类代码如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void inputStreamToFile(InputStream ins, File file) &#123;</span><br><span class="line">    OutputStream os = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        os = new FileOutputStream(file);</span><br><span class="line">        int bytesRead = 0;</span><br><span class="line">        byte[] buffer = new byte[1024];</span><br><span class="line">        while ((bytesRead = ins.read(buffer, 0, 1024)) != -1) &#123;</span><br><span class="line">            os.write(buffer, 0, bytesRead);</span><br><span class="line">        &#125;</span><br><span class="line">        os.close();</span><br><span class="line">        ins.close();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 问题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel操作</title>
      <link href="/2022/06/17/Excel%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/06/17/Excel%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ul><li>官网：<a href="https://www.yuque.com/easyexcel/doc/easyexcel">https://www.yuque.com/easyexcel/doc/easyexcel</a></li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="EasyExcelUtil"><a href="#EasyExcelUtil" class="headerlink" title="EasyExcelUtil"></a>EasyExcelUtil</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class EasyExcelUtil &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 同步无模型读（默认读取sheet0,从第2行开始读）</span><br><span class="line">     * @param filePath excel文件的绝对路径</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;Map&lt;Integer, String&gt;&gt; syncRead(String filePath)&#123;</span><br><span class="line">        return EasyExcelFactory.read(filePath).sheet().doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步无模型读（自定义读取sheetX，从第2行开始读）</span><br><span class="line">     * @param filePath excel文件的绝对路径</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;Map&lt;Integer, String&gt;&gt; syncRead(String filePath, Integer sheetNo)&#123;</span><br><span class="line">        return EasyExcelFactory.read(filePath).sheet(sheetNo).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步无模型读（指定sheet和表头占的行数）</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;Map&lt;Integer, String&gt;&gt; syncRead(String filePath, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        return EasyExcelFactory.read(filePath).sheet(sheetNo).headRowNumber(headRowNum).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步无模型读（指定sheet和表头占的行数）</span><br><span class="line">     * @param inputStream</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;Map&lt;Integer, String&gt;&gt; syncRead(InputStream inputStream, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        return EasyExcelFactory.read(inputStream).sheet(sheetNo).headRowNumber(headRowNum).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步无模型读（指定sheet和表头占的行数）</span><br><span class="line">     * @param file</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;Map&lt;Integer, String&gt;&gt; syncRead(File file, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        return EasyExcelFactory.read(file).sheet(sheetNo).headRowNumber(headRowNum).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line">//====================================================无JAVA模型读取excel数据===============================================================</span><br><span class="line"></span><br><span class="line">//====================================================将excel数据同步到JAVA模型属性里===============================================================</span><br><span class="line">    /**</span><br><span class="line">     * 同步按模型读（默认读取sheet0,从第2行开始读）</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;T&gt; syncReadModel(String filePath, Class clazz)&#123;</span><br><span class="line">        return EasyExcelFactory.read(filePath).sheet().head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步按模型读（默认表头占一行，从第2行开始读）</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;T&gt; syncReadModel(String filePath, Class clazz, Integer sheetNo)&#123;</span><br><span class="line">        return EasyExcelFactory.read(filePath).sheet(sheetNo).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步按模型读（指定sheet和表头占的行数）</span><br><span class="line">     * @param inputStream</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;ExcelWeldingData&gt; syncReadModel(InputStream inputStream, Class clazz, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        return EasyExcelFactory.read(inputStream).sheet(sheetNo).headRowNumber(headRowNum).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步按模型读（指定sheet和表头占的行数）</span><br><span class="line">     * @param file</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;T&gt; syncReadModel(File file, Class clazz, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        return EasyExcelFactory.read(file).sheet(sheetNo).headRowNumber(headRowNum).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步按模型读（指定sheet和表头占的行数）</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;T&gt; syncReadModel(String filePath, Class clazz, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        return EasyExcelFactory.read(filePath).sheet(sheetNo).headRowNumber(headRowNum).head(clazz).doReadSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步无模型读（默认读取sheet0,从第2行开始读）</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param filePath 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static void asyncRead(String filePath, AnalysisEventListener&lt;T&gt; excelListener)&#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, excelListener).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步无模型读（默认表头占一行，从第2行开始读）</span><br><span class="line">     * @param filePath 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     */</span><br><span class="line">    public static void asyncRead(String filePath, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo)&#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, excelListener).sheet(sheetNo).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步无模型读（指定sheet和表头占的行数）</span><br><span class="line">     * @param inputStream</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static void asyncRead(InputStream inputStream, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        EasyExcelFactory.read(inputStream, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步无模型读（指定sheet和表头占的行数）</span><br><span class="line">     * @param file</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static void asyncRead(File file, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        EasyExcelFactory.read(file, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步无模型读（指定sheet和表头占的行数）</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static void asyncRead(String filePath, AnalysisEventListener&lt;T&gt; excelListener, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步按模型读取（默认读取sheet0,从第2行开始读）</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     */</span><br><span class="line">    public static void asyncReadModel(String filePath, AnalysisEventListener&lt;ExcelWeldingData&gt; excelListener, Class clazz)&#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, clazz, excelListener).sheet().doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步按模型读取（默认表头占一行，从第2行开始读）</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     * @param sheetNo  sheet页号，从0开始</span><br><span class="line">     */</span><br><span class="line">    public static void asyncReadModel(String filePath, AnalysisEventListener&lt;T&gt; excelListener, Class clazz, Integer sheetNo)&#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, clazz, excelListener).sheet(sheetNo).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步按模型读取</span><br><span class="line">     * @param inputStream</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     * @param sheetNo  sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static void asyncReadModel(InputStream inputStream, AnalysisEventListener&lt;ExcelWeldingData&gt; excelListener, Class clazz, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        EasyExcelFactory.read(inputStream, clazz, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步按模型读取</span><br><span class="line">     * @param file</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     * @param sheetNo  sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static void asyncReadModel(File file, AnalysisEventListener&lt;T&gt; excelListener, Class clazz, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        EasyExcelFactory.read(file, clazz, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步按模型读取</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param excelListener 监听器，在监听器中可以处理行数据LinkedHashMap，表头数据，异常处理等</span><br><span class="line">     * @param clazz 模型的类类型（excel数据会按该类型转换成对象）</span><br><span class="line">     * @param sheetNo  sheet页号，从0开始</span><br><span class="line">     * @param headRowNum 表头占的行数，从0开始（如果要连表头一起读出来则传0）</span><br><span class="line">     */</span><br><span class="line">    public static void asyncReadModel(String filePath, AnalysisEventListener&lt;T&gt; excelListener, Class clazz, Integer sheetNo, Integer headRowNum)&#123;</span><br><span class="line">        EasyExcelFactory.read(filePath, clazz, excelListener).sheet(sheetNo).headRowNumber(headRowNum).doRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 无模板写文件</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param head 表头数据</span><br><span class="line">     * @param data 表内容数据</span><br><span class="line">     */</span><br><span class="line">    public static void write(String filePath, List&lt;List&lt;String&gt;&gt; head, List&lt;List&lt;Object&gt;&gt; data)&#123;</span><br><span class="line">        EasyExcel.write(filePath).head(head).sheet().doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 无模板写文件</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param head 表头数据</span><br><span class="line">     * @param data 表内容数据</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param sheetName sheet名称</span><br><span class="line">     */</span><br><span class="line">    public static void write(String filePath, List&lt;List&lt;String&gt;&gt; head, List&lt;List&lt;Object&gt;&gt; data, Integer sheetNo, String sheetName)&#123;</span><br><span class="line">        EasyExcel.write(filePath).head(head).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据excel模板文件写入文件</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param templateFileName</span><br><span class="line">     * @param headClazz</span><br><span class="line">     * @param data</span><br><span class="line">     */</span><br><span class="line">    public static void writeTemplate(HttpServletResponse response, String filePath, String templateFileName, Class headClazz, List data) throws IOException &#123;</span><br><span class="line">        ExcelWriter excelWriter = EasyExcel.write(response.getOutputStream(), headClazz).withTemplate(templateFileName).build();</span><br><span class="line">        WriteSheet sheet = EasyExcel.writerSheet().build();</span><br><span class="line">        excelWriter.fill(data,sheet);</span><br><span class="line">        response.setContentType(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            String fileName = URLEncoder.encode(filePath, &quot;UTF-8&quot;).replaceAll(&quot;\\+&quot;, &quot;%20&quot;);</span><br><span class="line">            response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename*=utf-8&#x27;&#x27;&quot; + fileName + &quot;.xlsx&quot;);</span><br><span class="line">            excelWriter.finish();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            // 重置response</span><br><span class="line">            response.reset();</span><br><span class="line">            response.setContentType(&quot;application/json&quot;);</span><br><span class="line">            response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">            Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">            map.put(&quot;status&quot;, &quot;failure&quot;);</span><br><span class="line">            map.put(&quot;message&quot;, &quot;下载文件失败&quot; + e.getMessage());</span><br><span class="line">            response.getWriter().println(JSON.toJSONString(map));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据excel模板文件写入文件</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param templateFileName</span><br><span class="line">     * @param headClazz</span><br><span class="line">     * @param data</span><br><span class="line">     */</span><br><span class="line">    public static void writeTemplate(String filePath, String templateFileName, Class headClazz, List data)&#123;</span><br><span class="line">        ExcelWriter excelWriter = EasyExcel.write(filePath, headClazz).withTemplate(templateFileName).build();</span><br><span class="line">        WriteSheet sheet = EasyExcel.writerSheet().build();</span><br><span class="line">        excelWriter.fill(data,sheet);</span><br><span class="line">        excelWriter.finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据excel模板文件写入文件</span><br><span class="line">     * @param filePath 保存路径</span><br><span class="line">     * @param templateFileName 模板路径</span><br><span class="line">     * @param data</span><br><span class="line">     */</span><br><span class="line">    public static void writeTemplate(String filePath, String templateFileName, List data)&#123;</span><br><span class="line">        ExcelWriter excelWriter = EasyExcel.write(filePath).withTemplate(templateFileName).build();</span><br><span class="line">        WriteSheet sheet = EasyExcel.writerSheet().build();</span><br><span class="line">        excelWriter.fill(data,sheet);</span><br><span class="line">        excelWriter.finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按模板写文件</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param headClazz 表头模板</span><br><span class="line">     * @param data 数据</span><br><span class="line">     */</span><br><span class="line">    public static void write(String filePath, Class headClazz, List data)&#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).sheet().doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按模板写文件</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param headClazz 表头模板</span><br><span class="line">     * @param data 数据</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param sheetName sheet名称</span><br><span class="line">     */</span><br><span class="line">    public static void write(String filePath, Class headClazz, List data, Integer sheetNo, String sheetName)&#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按模板写文件</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param headClazz 表头模板</span><br><span class="line">     * @param data 数据</span><br><span class="line">     * @param writeHandler 自定义的处理器，比如设置table样式，设置超链接、单元格下拉框等等功能都可以通过这个实现（需要注册多个则自己通过链式去调用）</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param sheetName sheet名称</span><br><span class="line">     */</span><br><span class="line">    public static void write(String filePath, Class headClazz, List data, WriteHandler writeHandler, Integer sheetNo, String sheetName)&#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).registerWriteHandler(writeHandler).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按模板写文件（包含某些字段）</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param headClazz 表头模板</span><br><span class="line">     * @param data 数据</span><br><span class="line">     * @param includeCols 包含字段集合，根据字段名称显示</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param sheetName sheet名称</span><br><span class="line">     */</span><br><span class="line">    public static void writeInclude(String filePath, Class headClazz, List data, Set&lt;String&gt; includeCols, Integer sheetNo, String sheetName)&#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).includeColumnFiledNames(includeCols).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按模板写文件（排除某些字段）</span><br><span class="line">     * @param filePath</span><br><span class="line">     * @param headClazz 表头模板</span><br><span class="line">     * @param data 数据</span><br><span class="line">     * @param excludeCols 过滤排除的字段，根据字段名称过滤</span><br><span class="line">     * @param sheetNo sheet页号，从0开始</span><br><span class="line">     * @param sheetName sheet名称</span><br><span class="line">     */</span><br><span class="line">    public static void writeExclude(String filePath, Class headClazz, List data, Set&lt;String&gt; excludeCols, Integer sheetNo, String sheetName)&#123;</span><br><span class="line">        EasyExcel.write(filePath, headClazz).excludeColumnFiledNames(excludeCols).sheet(sheetNo, sheetName).doWrite(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 多个sheet页的数据链式写入</span><br><span class="line">     * ExcelUtil.writeWithSheets(outputStream)</span><br><span class="line">     *                 .writeModel(ExcelModel.class, excelModelList, &quot;sheetName1&quot;)</span><br><span class="line">     *                 .write(headData, data,&quot;sheetName2&quot;)</span><br><span class="line">     *                 .finish();</span><br><span class="line">     * @param outputStream</span><br><span class="line">     */</span><br><span class="line">    public static EasyExcelWriterFactory writeWithSheets(OutputStream outputStream)&#123;</span><br><span class="line">        EasyExcelWriterFactory excelWriter = new EasyExcelWriterFactory(outputStream);</span><br><span class="line">        return excelWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 多个sheet页的数据链式写入</span><br><span class="line">     * ExcelUtil.writeWithSheets(file)</span><br><span class="line">     *                 .writeModel(ExcelModel.class, excelModelList, &quot;sheetName1&quot;)</span><br><span class="line">     *                 .write(headData, data,&quot;sheetName2&quot;)</span><br><span class="line">     *                 .finish();</span><br><span class="line">     * @param file</span><br><span class="line">     */</span><br><span class="line">    public static EasyExcelWriterFactory writeWithSheets(File file)&#123;</span><br><span class="line">        EasyExcelWriterFactory excelWriter = new EasyExcelWriterFactory(file);</span><br><span class="line">        return excelWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 多个sheet页的数据链式写入</span><br><span class="line">     * ExcelUtil.writeWithSheets(filePath)</span><br><span class="line">     *                 .writeModel(ExcelModel.class, excelModelList, &quot;sheetName1&quot;)</span><br><span class="line">     *                 .write(headData, data,&quot;sheetName2&quot;)</span><br><span class="line">     *                 .finish();</span><br><span class="line">     * @param filePath</span><br><span class="line">     */</span><br><span class="line">    public static EasyExcelWriterFactory writeWithSheets(String filePath)&#123;</span><br><span class="line">        EasyExcelWriterFactory excelWriter = new EasyExcelWriterFactory(filePath);</span><br><span class="line">        return excelWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 多个sheet页的数据链式写入（失败了会返回一个有部分数据的Excel）</span><br><span class="line">     * ExcelUtil.writeWithSheets(response, exportFileName)</span><br><span class="line">     *                 .writeModel(ExcelModel.class, excelModelList, &quot;sheetName1&quot;)</span><br><span class="line">     *                 .write(headData, data,&quot;sheetName2&quot;)</span><br><span class="line">     *                 .finish();</span><br><span class="line">     * @param response</span><br><span class="line">     * @param exportFileName 导出的文件名称</span><br><span class="line">     */</span><br><span class="line">    public static EasyExcelWriterFactory writeWithSheetsWeb(HttpServletResponse response, String exportFileName) throws IOException &#123;</span><br><span class="line">        response.setContentType(&quot;application/vnd.ms-excel&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        // 这里URLEncoder.encode可以防止中文乱码</span><br><span class="line">        String fileName = URLEncoder.encode(exportFileName, &quot;UTF-8&quot;);</span><br><span class="line">        response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + fileName + &quot;.xlsx&quot;);</span><br><span class="line">        EasyExcelWriterFactory excelWriter = new EasyExcelWriterFactory(response.getOutputStream());</span><br><span class="line">        return excelWriter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步监听器"><a href="#异步监听器" class="headerlink" title="异步监听器"></a>异步监听器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class DefaultExcelListener&lt;T&gt; extends AnalysisEventListener&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void invoke(T data, AnalysisContext context) &#123;</span><br><span class="line">        list.add(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doAfterAllAnalysed(AnalysisContext context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class EasyExcelWriterFactory &#123;</span><br><span class="line">    private int sheetNo = 0;</span><br><span class="line">    private ExcelWriter excelWriter = null;</span><br><span class="line"></span><br><span class="line">    public EasyExcelWriterFactory(OutputStream outputStream) &#123;</span><br><span class="line">        excelWriter = EasyExcel.write(outputStream).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EasyExcelWriterFactory(File file) &#123;</span><br><span class="line">        excelWriter = EasyExcel.write(file).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EasyExcelWriterFactory(String filePath) &#123;</span><br><span class="line">        excelWriter = EasyExcel.write(filePath).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链式模板表头写入</span><br><span class="line">     * @param headClazz 表头格式</span><br><span class="line">     * @param data 数据 List&lt;ExcelModel&gt; 或者List&lt;List&lt;Object&gt;&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public EasyExcelWriterFactory writeModel(Class headClazz, List data, String sheetName)&#123;</span><br><span class="line">        excelWriter.write(data, EasyExcel.writerSheet(this.sheetNo++, sheetName).head(headClazz).build());</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链式自定义表头写入</span><br><span class="line">     * @param head</span><br><span class="line">     * @param data 数据 List&lt;ExcelModel&gt; 或者List&lt;List&lt;Object&gt;&gt;</span><br><span class="line">     * @param sheetName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public EasyExcelWriterFactory write(List&lt;List&lt;String&gt;&gt; head, List data, String sheetName)&#123;</span><br><span class="line">        excelWriter.write(data, EasyExcel.writerSheet(this.sheetNo++, sheetName).head(head).build());</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用此类结束后，一定要关闭流</span><br><span class="line">     */</span><br><span class="line">    public void finish() &#123;</span><br><span class="line">        excelWriter.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File文件转换</title>
      <link href="/2022/06/17/File%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/06/17/File%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<ul><li>MultipartFile转File</li><li>File转MultipartFile</li><li>InputSteam转File</li></ul><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MultipartFileUtil &#123;</span><br><span class="line">    /**</span><br><span class="line">     * MultipartFile 转 File</span><br><span class="line">     *</span><br><span class="line">     * @param file</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static File multipartFileToFile(MultipartFile file) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        File toFile = null;</span><br><span class="line">        if (file.equals(&quot;&quot;) || file.getSize() &lt;= 0) &#123;</span><br><span class="line">            file = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            InputStream ins = null;</span><br><span class="line">            ins = file.getInputStream();</span><br><span class="line">            toFile = new File(file.getOriginalFilename());</span><br><span class="line">            inputStreamToFile(ins, toFile);</span><br><span class="line">            ins.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return toFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * File 转 MultipartFile</span><br><span class="line">     *</span><br><span class="line">     * @param file</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static MultipartFile fileToMultipartFile(File file)  &#123;</span><br><span class="line">        MultipartFile cMultiFile = null;</span><br><span class="line">        String contentType = new MimetypesFileTypeMap().getContentType(new File(file.toString()));</span><br><span class="line">        try &#123;</span><br><span class="line">            cMultiFile = new MockMultipartFile(&quot;file&quot;, file.getName(), contentType, new FileInputStream(file));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return cMultiFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * InputStream 转 File</span><br><span class="line">     * @param inputStream</span><br><span class="line">     * @param file 文件存储路径</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static void inputStreamToFile(InputStream inputStream, File file) &#123;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            os = new FileOutputStream(file);</span><br><span class="line"></span><br><span class="line">            int bytesRead = 0;</span><br><span class="line">            byte[] buffer = new byte[1024];</span><br><span class="line">            while ((bytesRead = ins.read(buffer, 0, 1024)) != -1) &#123;</span><br><span class="line">                os.write(buffer, 0, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            os.close();</span><br><span class="line">            ins.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除本地临时文件</span><br><span class="line">     * @param file</span><br><span class="line">     */</span><br><span class="line">    public static void delteTempFile(File file) &#123;</span><br><span class="line">        if (file != null) &#123;</span><br><span class="line">            File del = new File(file.toURI());</span><br><span class="line">            del.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @param: [directory] 文件路径</span><br><span class="line">     * @return: boolean</span><br><span class="line">     * 删除指定文件</span><br><span class="line">     */</span><br><span class="line">    public static boolean deleteDirectory(String directory) &#123;</span><br><span class="line">        if (!directory.endsWith(File.separator)) &#123;</span><br><span class="line">            directory = directory + File.separator;</span><br><span class="line">        &#125;</span><br><span class="line">        File directoryFile = new File(directory);</span><br><span class="line">        // 判断directory对应的文件是否存在，或者是否是一个文件夹</span><br><span class="line">        if (!directoryFile.exists() || !directoryFile.isDirectory()) &#123;</span><br><span class="line">            log.info(&quot;文件夹删除失败，文件夹&#123;&#125;不存在&quot; , directory);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean flag = true;</span><br><span class="line">        // 删除文件夹下的所有文件和文件夹</span><br><span class="line">        File[] files = directoryFile.listFiles();</span><br><span class="line">        for (int i = 0; i &lt; files.length; i++) &#123;  // 循环删除所有的子文件及子文件夹</span><br><span class="line">            // 删除子文件</span><br><span class="line">            if (files[i].isFile()) &#123;</span><br><span class="line">                flag = deleteFile(files[i].getAbsolutePath());</span><br><span class="line">                if (!flag) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;  // 删除子文件夹</span><br><span class="line">                flag = deleteDirectory(files[i].getAbsolutePath());</span><br><span class="line">                if (!flag) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            log.info(&quot;文件夹删除文件失败：&#123;&#125;&quot;,directory);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 最后删除当前文件夹</span><br><span class="line">        if (directoryFile.delete()) &#123;</span><br><span class="line">            log.info(&quot;文件夹删除文件成功：&#123;&#125;&quot;,directory);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;文件夹删除文件失败：&#123;&#125;&quot;,directory);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minio</title>
      <link href="/2022/06/17/minio/"/>
      <url>/2022/06/17/minio/</url>
      
        <content type="html"><![CDATA[<p>minio为开源的高可用分部署对象存储服务组件，已经提供了分布式部署的解决方案，实现高可靠、高可用的资源存储，MinIO以极简主义为指导进行设计，追求极致的维护精简性和卓越的读写性能表现</p><span id="more"></span><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- minio依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.minio&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;minio&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;8.3.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 官方 miniodemo需要的依赖--&gt;</span><br></pre></td></tr></table></figure><h2 id="yaml配置"><a href="#yaml配置" class="headerlink" title="yaml配置"></a>yaml配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oss:</span><br><span class="line">  enabled: true</span><br><span class="line">  name: minio</span><br><span class="line">  tenant-mode: false</span><br><span class="line">  endpoint: http://127.0.0.1:9000/</span><br><span class="line">  access-key: accessKey</span><br><span class="line">  secret-key: secretKey</span><br><span class="line">  bucket-name: 桶名称</span><br></pre></td></tr></table></figure><h2 id="MinioTemplate"><a href="#MinioTemplate" class="headerlink" title="MinioTemplate"></a>MinioTemplate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MinioTemplate implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    //在配置文件中指定</span><br><span class="line">    @Value(&quot;$&#123;oss.endpoint&#125;&quot;)</span><br><span class="line">    private String ENDPOINT;</span><br><span class="line">    @Value(&quot;$&#123;oss.bucket-name&#125;&quot;)</span><br><span class="line">    private String BUCKET_NAME;</span><br><span class="line">    @Value(&quot;$&#123;oss.access-key&#125;&quot;)</span><br><span class="line">    private String ACCESS_KEY;</span><br><span class="line">    @Value(&quot;$&#123;oss.secret-key&#125;&quot;)</span><br><span class="line">    private String SECRET_KEY;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MinioClient client;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        //断言</span><br><span class="line">        Assert.hasText(ENDPOINT, &quot;Minio url 为空&quot;);</span><br><span class="line">        Assert.hasText(ACCESS_KEY, &quot;Minio accessKey为空&quot;);</span><br><span class="line">        Assert.hasText(SECRET_KEY, &quot;Minio secretKey为空&quot;);</span><br><span class="line">        this.client  =</span><br><span class="line">                MinioClient.builder()</span><br><span class="line">                        .endpoint(ENDPOINT)</span><br><span class="line">                        .credentials(ACCESS_KEY, SECRET_KEY)</span><br><span class="line">                        .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建bucket</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     */</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public void createBucket() &#123;</span><br><span class="line">        if (! client.bucketExists(BucketExistsArgs.builder().bucket(BUCKET_NAME).build())) &#123;</span><br><span class="line">            client.makeBucket(MakeBucketArgs.builder().bucket(BUCKET_NAME).build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 创建bucket</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     */</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public void createBucket(String bucketName) &#123;</span><br><span class="line">        if (! client.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build())) &#123;</span><br><span class="line">            client.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取全部bucket</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * https://docs.minio.io/cn/java-client-api-reference.html#listBuckets</span><br><span class="line">     */</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public List&lt;Bucket&gt; getAllBuckets() &#123;</span><br><span class="line">        // 列出所有存储桶</span><br><span class="line">        return client.listBuckets();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据bucketName获取信息</span><br><span class="line">     *</span><br><span class="line">     * @param bucketName bucket名称</span><br><span class="line">     */</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public Optional&lt;Bucket&gt; getBucket(String bucketName) &#123;</span><br><span class="line">        return client.listBuckets().stream().filter(b -&gt; b.name().equals(bucketName)).findFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据bucketName删除信息</span><br><span class="line">     *</span><br><span class="line">     * @param bucketName bucket名称</span><br><span class="line">     */</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public void removeBucket(String bucketName) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 删除之前先检查`my-bucket`是否存在。</span><br><span class="line">            boolean found = client.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());</span><br><span class="line">            if (found) &#123;</span><br><span class="line">                // 删除`my-bucketname`存储桶，注意，只有存储桶为空时才能删除成功。</span><br><span class="line">                client.deleteBucketPolicy(DeleteBucketPolicyArgs.builder().bucket(bucketName).build());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;mybucket does not exist&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(MinioException e) &#123;</span><br><span class="line">            System.out.println(&quot;根据bucketName删除信息失败: &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据文件前置查询文件</span><br><span class="line">     *</span><br><span class="line">     * @param prefix     前缀</span><br><span class="line">     * @param recursive  是否递归查询</span><br><span class="line">     * @return MinioItem 列表</span><br><span class="line">     */</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public List&lt;Item&gt; getAllObjectsByPrefix(String prefix, boolean recursive) &#123;</span><br><span class="line">        List&lt;Item&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Iterable&lt;Result&lt;Item&gt;&gt; objectsIterator = client.listObjects(</span><br><span class="line">                ListObjectsArgs.builder().bucket(BUCKET_NAME).prefix(prefix)</span><br><span class="line">                        .recursive(recursive).build()</span><br><span class="line">        );</span><br><span class="line">        if (objectsIterator != null) &#123;</span><br><span class="line">            Iterator&lt;Result&lt;Item&gt;&gt; iterator = objectsIterator.iterator();</span><br><span class="line">            if (iterator != null) &#123;</span><br><span class="line">                while (iterator.hasNext()) &#123;</span><br><span class="line">                    Result&lt;Item&gt; result = iterator.next();</span><br><span class="line">                    Item item = result.get();</span><br><span class="line">                    list.add(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取文件外链</span><br><span class="line">     *</span><br><span class="line">     * @param objectName 文件名称</span><br><span class="line">     * @param expires    过期时间 &lt;=7</span><br><span class="line">     * @return url</span><br><span class="line">     */</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public String getObjectURL(String objectName, Integer expires) &#123;</span><br><span class="line">        BucketExistsArgs bucketArgs = BucketExistsArgs.builder().bucket(BUCKET_NAME).build();</span><br><span class="line">        boolean bucketExists = client.bucketExists(bucketArgs);</span><br><span class="line">        String url = &quot;&quot;;</span><br><span class="line">        if (bucketExists) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (expires == null)&#123;</span><br><span class="line">                    expires = 5;</span><br><span class="line">                &#125;</span><br><span class="line">                GetPresignedObjectUrlArgs getPresignedObjectUrlArgs = GetPresignedObjectUrlArgs.builder()</span><br><span class="line">                        .method(Method.GET)</span><br><span class="line">                        .bucket(BUCKET_NAME)</span><br><span class="line">                        .object(objectName)</span><br><span class="line">                        .expiry(expires, TimeUnit.DAYS)</span><br><span class="line">                        .build();</span><br><span class="line">                url = client.getPresignedObjectUrl(getPresignedObjectUrlArgs);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.info(&quot;presigned get object fail:&#123;&#125;&quot;,e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将URLDecoder编码转成UTF8</span><br><span class="line">     * @param str</span><br><span class="line">     */</span><br><span class="line">    protected static String getUtf8ByURLDecoder(String str)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String url = str.replaceAll(&quot;%(?![0-9a-fA-F]&#123;2&#125;)&quot;, &quot;%25&quot;);</span><br><span class="line">            return URLDecoder.decode(url, &quot;UTF-8&quot;);</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取文件</span><br><span class="line">     *</span><br><span class="line">     * @param bucketName bucket名称</span><br><span class="line">     * @param objectName 文件名称</span><br><span class="line">     * @return 二进制流</span><br><span class="line">     */</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public InputStream getObject(String bucketName, String objectName) &#123;</span><br><span class="line">        return client.getObject( GetObjectArgs.builder()</span><br><span class="line">                .bucket(bucketName)</span><br><span class="line">                .object(objectName)</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 上传文件</span><br><span class="line">     *</span><br><span class="line">     * @param bucketName bucket名称</span><br><span class="line">     * @param objectName 文件名称</span><br><span class="line">     * @param stream     文件流</span><br><span class="line">     * @throws Exception https://docs.minio.io/cn/java-client-api-reference.html#putObject</span><br><span class="line">     */</span><br><span class="line">    public void putObject(String bucketName, String objectName, InputStream stream) throws Exception &#123;</span><br><span class="line">        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();</span><br><span class="line">        headers.put(&quot;X-Amz-Storage-Class&quot;, &quot;REDUCED_REDUNDANCY&quot;);</span><br><span class="line">        Map&lt;String, String&gt; userMetadata = new HashMap&lt;&gt;();</span><br><span class="line">        userMetadata.put(&quot;My-Project&quot;, &quot;Project One&quot;);</span><br><span class="line">        client.putObject(</span><br><span class="line">                PutObjectArgs.builder().bucket(bucketName).object(objectName).stream(</span><br><span class="line">                        stream, stream.available(), -1)</span><br><span class="line">                        .headers(headers)</span><br><span class="line">                        .userMetadata(userMetadata)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 上传文件</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     * @param objectName  文件名称</span><br><span class="line">     * @param stream      文件流</span><br><span class="line">     * @param size        大小</span><br><span class="line">     * @param contextType 类型</span><br><span class="line">     * @throws Exception https://docs.minio.io/cn/java-client-api-reference.html#putObject</span><br><span class="line">     */</span><br><span class="line">    public void putObject(String objectName, InputStream stream, long size, String contextType) throws Exception &#123;</span><br><span class="line">        boolean found = client.bucketExists(BucketExistsArgs.builder().bucket(BUCKET_NAME).build());</span><br><span class="line">        if (!found)&#123;</span><br><span class="line">            createBucket();</span><br><span class="line">        &#125;</span><br><span class="line">        client.putObject(</span><br><span class="line">                PutObjectArgs.builder().bucket(BUCKET_NAME)</span><br><span class="line">                        .object(objectName).stream(stream,size, -1)</span><br><span class="line">                        .contentType(contextType).build());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 判断文件是否存在</span><br><span class="line">     *</span><br><span class="line">     * @param objectName 文件名称, 如果要带文件夹请用 / 分割, 例如 /help/index.html</span><br><span class="line">     * @return true存在, 反之</span><br><span class="line">     */</span><br><span class="line">    public Boolean checkFileIsExist(String objectName) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            client.statObject(</span><br><span class="line">                    StatObjectArgs.builder().bucket(BUCKET_NAME).object(objectName).build()</span><br><span class="line">            );</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取文件信息, 如果抛出异常则说明文件不存在</span><br><span class="line">     *</span><br><span class="line">     * @param objectName 文件名称</span><br><span class="line">     * @throws Exception https://docs.minio.io/cn/java-client-api-reference.html#statObject</span><br><span class="line">     */</span><br><span class="line">    public StatObjectResponse getObjectInfo(String objectName) throws Exception &#123;</span><br><span class="line">        StatObjectResponse statObjectResponse = client.statObject(StatObjectArgs.builder().bucket(BUCKET_NAME).object(objectName).build());</span><br><span class="line">        statObjectResponse.legalHold();</span><br><span class="line">        System.out.println();</span><br><span class="line">        return statObjectResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除文件</span><br><span class="line">     *</span><br><span class="line">     * @param objectName 文件名称</span><br><span class="line">     * @throws Exception https://docs.minio.io/cn/java-client-api-reference.html#removeObject</span><br><span class="line">     */</span><br><span class="line">    public boolean removeObject(String objectName) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            client.removeObject(</span><br><span class="line">                    RemoveObjectArgs.builder()</span><br><span class="line">                            .bucket(BUCKET_NAME)</span><br><span class="line">                            .object(objectName)</span><br><span class="line">                            .build());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 每天 00:00:00 清除minio云存储的错误日志</span><br><span class="line">   * @return: void</span><br><span class="line">*/</span><br><span class="line">@Scheduled(cron = &quot;0 0 0 * * ?&quot;)</span><br><span class="line">public void cleanMinioError()&#123;</span><br><span class="line">    String name = &quot;/errorModel/焊评错误数据&quot;;</span><br><span class="line">    // 获取minio文件多级目录</span><br><span class="line">    List&lt;Item&gt; list = minioTemplate.getAllObjectsByPrefix(name, false);</span><br><span class="line">    if (Boolean.FALSE.equals(list.isEmpty()))&#123;</span><br><span class="line">        list.forEach(e -&gt; &#123;</span><br><span class="line">            // 检查该文件是否存在</span><br><span class="line">            Boolean isExist = minioTemplate.checkFileIsExist(e.objectName());</span><br><span class="line">            if (Boolean.TRUE.equals(isExist))&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 删除minio上的文件</span><br><span class="line">                    boolean removeObject = minioTemplate.removeObject(e.objectName());</span><br><span class="line">                    if (Boolean.TRUE.equals(removeObject))&#123;</span><br><span class="line">                        log.info(&quot;&#123;&#125;&quot;,e.objectName()+&quot;————删除成功&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception exception) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">   // 判断文件是否存在</span><br><span class="line">   Boolean isExist = minioTemplate.checkFileIsExist(originalFilename);</span><br><span class="line">   if (Boolean.FALSE.equals(isExist))&#123;</span><br><span class="line">      // 文件上传</span><br><span class="line">      minioTemplate.putObject(originalFilename, multiFile.getInputStream(), multiFile.getSize(), mimeType);</span><br><span class="line">   &#125;</span><br><span class="line">   // 获取已存在的文件路径</span><br><span class="line">   String url = minioTemplate.getObjectURL(originalFilename, 7);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> minio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压缩包解压zip&amp;rar</title>
      <link href="/2022/06/17/%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%A7%A3%E5%8E%8Bzip-rar/"/>
      <url>/2022/06/17/%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%A7%A3%E5%8E%8Bzip-rar/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--zip4j依赖,解压zip压缩--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 解压zip文件</span><br><span class="line"> * @param srcPath 源文件地址</span><br><span class="line"> * @param targetDir 目标文件地址</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static String unZip(String srcPath, String targetDir) &#123;</span><br><span class="line">    String name = &quot;/&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">        BufferedOutputStream dest = null;</span><br><span class="line">        BufferedInputStream is = null;</span><br><span class="line">        ZipEntry entry;</span><br><span class="line">        ZipFile zipfile = new ZipFile(srcPath, Charset.forName(&quot;GBK&quot;));</span><br><span class="line">        // ZipFile zipfile = new ZipFile(srcPath);</span><br><span class="line">        Enumeration dir = zipfile.entries();</span><br><span class="line">        while (dir.hasMoreElements()) &#123;</span><br><span class="line">            entry = (ZipEntry) dir.nextElement();</span><br><span class="line"></span><br><span class="line">            if (entry.isDirectory()) &#123;</span><br><span class="line">                name = entry.getName();</span><br><span class="line">                name = name.substring(0, name.length() - 1);</span><br><span class="line">                File fileObject = new File(targetDir + name);</span><br><span class="line">                fileObject.mkdir();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Enumeration e = zipfile.entries();</span><br><span class="line">        while (e.hasMoreElements()) &#123;</span><br><span class="line">            entry = (ZipEntry) e.nextElement();</span><br><span class="line">            if (entry.isDirectory()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                is = new BufferedInputStream(zipfile.getInputStream(entry));</span><br><span class="line">                int count;</span><br><span class="line">                byte[] dataByte = new byte[2048];</span><br><span class="line">                FileOutputStream fos = new FileOutputStream(targetDir + entry.getName());</span><br><span class="line">                dest = new BufferedOutputStream(fos, 2048);</span><br><span class="line">                while ((count = is.read(dataByte, 0, 2048)) != -1) &#123;</span><br><span class="line">                    dest.write(dataByte, 0, count);</span><br><span class="line">                &#125;</span><br><span class="line">                dest.flush();</span><br><span class="line">                dest.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h2><ul><li>java库没有对rar5压缩算法实现，github有官方自己实现好的库<br><a href="https://mvnrepository.com/artifact/com.github.axet/java-unrar">https://mvnrepository.com/artifact/com.github.axet/java-unrar</a></li></ul><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--解压rar5,所需依赖开始--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.axet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-unrar&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.0-8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sevenzipjbinding&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;16.02-2.01&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sf.sevenzipjbinding&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sevenzipjbinding-all-platforms&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;16.02-2.01&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--解压rar5,所需依赖结束--&gt;</span><br></pre></td></tr></table></figure><h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 解压rar文件</span><br><span class="line"> * @param path 源文件地址</span><br><span class="line"> * @param dstDirectoryPath 目标文件地址</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static List&lt;String&gt; unRar(String path, String dstDirectoryPath) throws IOException &#123;</span><br><span class="line">    File rarPath = new File(path);</span><br><span class="line">    int index = path.lastIndexOf(&quot;/&quot;);</span><br><span class="line">    String substring = path.substring(index + 1);</span><br><span class="line">    int indexOf = substring.lastIndexOf(&quot;.&quot;);</span><br><span class="line">    String url = substring.substring(0,indexOf);</span><br><span class="line"></span><br><span class="line">    IInArchive archive;</span><br><span class="line">    RandomAccessFile randomAccessFile;</span><br><span class="line">    // 第一个参数是需要解压的压缩包路径，第二个参数参考JdkAPI文档的RandomAccessFile</span><br><span class="line">    //r代表以只读的方式打开文本，也就意味着不能用write来操作文件</span><br><span class="line">    randomAccessFile = new RandomAccessFile(rarPath, &quot;r&quot;);</span><br><span class="line">    archive = SevenZip.openInArchive(null, // null - autodetect</span><br><span class="line">            new RandomAccessFileInStream(randomAccessFile));</span><br><span class="line">    int[] in = new int[archive.getNumberOfItems()];</span><br><span class="line">    for (int i = 0; i &lt; in.length; i++) &#123;</span><br><span class="line">        in[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    archive.extract(in, false, new ExtractCallback(archive,dstDirectoryPath));</span><br><span class="line">    archive.close();</span><br><span class="line">    randomAccessFile.close();</span><br><span class="line">    ///data/microService/data/offline_dzhd_pdf/pdf/1637724142062/</span><br><span class="line">    // System.out.println(&quot;rar文件解压目标文件夹为：&quot;+dstDirectoryPath);</span><br><span class="line">    List&lt;String&gt; allFileList = getAllFile(dstDirectoryPath + url, false);</span><br><span class="line">    return getAllFile(allFileList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己编写回调ExtractCallback</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExtractCallback implements IArchiveExtractCallback &#123;</span><br><span class="line"></span><br><span class="line">    private int index;</span><br><span class="line">    private IInArchive inArchive;</span><br><span class="line">    private String ourDir;</span><br><span class="line"></span><br><span class="line">    public ExtractCallback(IInArchive inArchive, String ourDir) &#123;</span><br><span class="line">        this.inArchive = inArchive;</span><br><span class="line">        this.ourDir = ourDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setCompleted(long arg0) throws SevenZipException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setTotal(long arg0) throws SevenZipException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ISequentialOutStream getStream(int index, ExtractAskMode extractAskMode) throws SevenZipException &#123;</span><br><span class="line">        this.index = index;</span><br><span class="line">        final String path = (String) inArchive.getProperty(index, PropID.PATH);</span><br><span class="line">        final boolean isFolder = (boolean) inArchive.getProperty(index, PropID.IS_FOLDER);</span><br><span class="line">        final String[] oldPath = &#123;&quot;&quot;&#125;;</span><br><span class="line">        return new ISequentialOutStream() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int write(byte[] data) throws SevenZipException &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (!isFolder) &#123;</span><br><span class="line">//                        System.out.println(path);</span><br><span class="line">                        File file = new File(ourDir+&quot;\\&quot; + path);</span><br><span class="line">                        if (path.equals(oldPath[0]))&#123;</span><br><span class="line">                            save2File(file, data,true);</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            save2File(file, data,false);</span><br><span class="line">                        &#125;</span><br><span class="line">                        oldPath[0] = path;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return data.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepareOperation(ExtractAskMode arg0) throws SevenZipException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setOperationResult(ExtractOperationResult extractOperationResult) throws SevenZipException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //解决字节丢失  未验证</span><br><span class="line">    public boolean save2File(File file, byte[] msg,boolean append) &#123;</span><br><span class="line">        OutputStream fos = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            File parent = file.getParentFile();</span><br><span class="line">            boolean bool;</span><br><span class="line">            if ((!parent.exists()) &amp;&amp; (!parent.mkdirs())) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //            fos = new FileOutputStream(file);</span><br><span class="line">            fos = new FileOutputStream(file,append);//是否追加</span><br><span class="line">            fos.write(msg);</span><br><span class="line">            fos.flush();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            File parent;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (fos != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean save2File(File file, byte[] msg) &#123;</span><br><span class="line">        OutputStream fos = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            File parent = file.getParentFile();</span><br><span class="line">            if ((!parent.exists()) &amp;&amp; (!parent.mkdirs())) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            fos = new FileOutputStream(file, true);</span><br><span class="line">            fos.write(msg);</span><br><span class="line">            fos.flush();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h2><h3 id="获取路径下的所有文件-文件夹"><a href="#获取路径下的所有文件-文件夹" class="headerlink" title="获取路径下的所有文件/文件夹"></a>获取路径下的所有文件/文件夹</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取路径下的所有文件/文件夹</span><br><span class="line"> * @param directoryPath 需要遍历的文件夹路径</span><br><span class="line"> * @param isAddDirectory 是否将子文件夹的路径也添加到list集合中</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static List&lt;String&gt; getAllFile(String directoryPath,boolean isAddDirectory) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">    File baseFile = new File(directoryPath);</span><br><span class="line">    if (baseFile.isFile() || !baseFile.exists()) &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    File[] files = baseFile.listFiles();</span><br><span class="line">    for (File file : files) &#123;</span><br><span class="line">        if (file.isDirectory()) &#123;</span><br><span class="line">            if(isAddDirectory)&#123;</span><br><span class="line">                list.add(file.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">            list.addAll(getAllFile(file.getAbsolutePath(),isAddDirectory));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            list.add(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getAllFile(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static List&lt;String&gt; getAllFile(List&lt;String&gt; list)&#123;</span><br><span class="line">    ArrayList&lt;String&gt; resultFileList = new ArrayList&lt;&gt;();</span><br><span class="line">    String startString;</span><br><span class="line">    String endString;</span><br><span class="line">    String fianllyString;</span><br><span class="line">    for (String s : list) &#123;</span><br><span class="line">        if(s.startsWith(&quot;/&quot;) || s.startsWith(&quot;\\&quot;))&#123;</span><br><span class="line">            startString = s.substring(0,s.lastIndexOf(&quot;\\&quot;));</span><br><span class="line">            endString = s.substring(s.lastIndexOf(&quot;\\&quot;)+1);</span><br><span class="line">            fianllyString = startString+&quot;\\&quot;+endString;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //windows系统去掉盘符</span><br><span class="line">            s =s.substring(2);</span><br><span class="line">            startString = s.substring(0,s.lastIndexOf(&quot;\\&quot;));</span><br><span class="line">            endString = s.substring(s.lastIndexOf(&quot;\\&quot;)+1);</span><br><span class="line">            fianllyString = startString+ &quot;/&quot; + endString;</span><br><span class="line">        &#125;</span><br><span class="line">        // System.out.println(startString+endString);</span><br><span class="line">        //解决liunx路径出现//导致文件路径错误</span><br><span class="line">        fianllyString = fianllyString.replaceAll(&quot;//&quot;,&quot;/&quot;);</span><br><span class="line">        resultFileList.add(fianllyString);</span><br><span class="line">    &#125;</span><br><span class="line">    // System.out.println(&quot;rar解压文件路径为&quot;+resultFileList);</span><br><span class="line">    return resultFileList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除指定路径下的文件"><a href="#删除指定路径下的文件" class="headerlink" title="删除指定路径下的文件"></a>删除指定路径下的文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * @param: [fileName] 文件路径</span><br><span class="line">   * @return: boolean</span><br><span class="line"> * 删除指定文件</span><br><span class="line">*/</span><br><span class="line">public static boolean deleteFile(String fileName) &#123;</span><br><span class="line">    File file = new File(fileName);</span><br><span class="line">    if (file.isFile() &amp;&amp; file.exists()) &#123;</span><br><span class="line">        file.delete();</span><br><span class="line">        log.info(&quot;删除文件成功：&#123;&#125;&quot;,fileName);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.info(&quot;删除文件失败：&#123;&#125;&quot;,fileName);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param: [directory] 文件路径</span><br><span class="line"> * @return: boolean</span><br><span class="line"> * 删除指定文件</span><br><span class="line"> */</span><br><span class="line">public static boolean deleteDirectory(String directory) &#123;</span><br><span class="line">    if (!directory.endsWith(File.separator)) &#123;</span><br><span class="line">        directory = directory + File.separator;</span><br><span class="line">    &#125;</span><br><span class="line">    File directoryFile = new File(directory);</span><br><span class="line">    // 判断directory对应的文件是否存在，或者是否是一个文件夹</span><br><span class="line">    if (!directoryFile.exists() || !directoryFile.isDirectory()) &#123;</span><br><span class="line">        log.info(&quot;文件夹删除失败，文件夹&#123;&#125;不存在&quot; , directory);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean flag = true;</span><br><span class="line">    // 删除文件夹下的所有文件和文件夹</span><br><span class="line">    File[] files = directoryFile.listFiles();</span><br><span class="line">    for (int i = 0; i &lt; files.length; i++) &#123;  // 循环删除所有的子文件及子文件夹</span><br><span class="line">        // 删除子文件</span><br><span class="line">        if (files[i].isFile()) &#123;</span><br><span class="line">            flag = deleteFile(files[i].getAbsolutePath());</span><br><span class="line">            if (!flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;  // 删除子文件夹</span><br><span class="line">            flag = deleteDirectory(files[i].getAbsolutePath());</span><br><span class="line">            if (!flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!flag) &#123;</span><br><span class="line">        log.info(&quot;文件夹删除文件失败：&#123;&#125;&quot;,directory);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后删除当前文件夹</span><br><span class="line">    if (directoryFile.delete()) &#123;</span><br><span class="line">        log.info(&quot;文件夹删除文件成功：&#123;&#125;&quot;,directory);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.info(&quot;文件夹删除文件失败：&#123;&#125;&quot;,directory);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zip&amp;rar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 压缩包解压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttpClient</title>
      <link href="/2022/05/12/OkHttpClient/"/>
      <url>/2022/05/12/OkHttpClient/</url>
      
        <content type="html"><![CDATA[<p><strong>OkHttpClient</strong></p><p>OkHttpClient是一个高效的HTTP客户端</p><ul><li>支持HTTP/2，允许所有同一个主机地址的请求共享同一个 <code>socket</code> 连接</li><li>连接池减少请求延时</li><li>透明的GZIP压缩减少响应数据的大小</li><li>缓存响应内容，避免一些完全重复的请求</li><li>当网络出现问题时 <code>OkHttp</code>，会自动恢复一般的连接问题</li></ul><p><strong>依赖</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;okhttp&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.14.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p><strong>简单使用</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OkHttpClientUtil &#123;</span><br><span class="line">    private static final String TYPE_JSON = &quot;application/json; charset=utf-8&quot;;</span><br><span class="line">    private static final String TYPE_FORM = &quot;application/data;&quot;;</span><br><span class="line">    private static final String TYPE_FORM_DATA = &quot;multipart/form-data;&quot;;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">    * @Description: post-&gt;json</span><br><span class="line">    * @Param: [url, json]</span><br><span class="line">    * @return: java.lang.String</span><br><span class="line">    * @Date: 2022/4/27</span><br><span class="line">    */</span><br><span class="line">    public static String postJson(String url,String json)&#123;</span><br><span class="line">        RequestBody body = RequestBody.create(MediaType.parse(TYPE_JSON), json);</span><br><span class="line">        return post(url,TYPE_JSON,null,body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: post-&gt;json</span><br><span class="line">     * @Param: [url, headerMap, json]</span><br><span class="line">     * @return: java.lang.String</span><br><span class="line">     * @Date: 2022/4/27</span><br><span class="line">     */</span><br><span class="line">    public static String postJson(String url,Map&lt;String ,String&gt; headerMap,String json)&#123;</span><br><span class="line">        RequestBody body = RequestBody.create(MediaType.parse(TYPE_JSON), json);</span><br><span class="line">        return post(url,TYPE_JSON,headerMap,body);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @Description: post-&gt;form</span><br><span class="line">     * @Param: [url, headerMap, parametersBody]</span><br><span class="line">     * @return: java.lang.String</span><br><span class="line">     * @Date: 2022/4/27</span><br><span class="line">     */</span><br><span class="line">    public static String postForm(String url,Map&lt;String ,String&gt; headerMap,Map&lt;String,String&gt; parametersBody)&#123;</span><br><span class="line">        //请求体</span><br><span class="line">        MultipartBody.Builder bodybuilder = new MultipartBody.Builder();</span><br><span class="line">        if (!ObjectUtils.isEmpty(parametersBody))&#123;</span><br><span class="line">            parametersBody.forEach(bodybuilder::addFormDataPart);</span><br><span class="line">        &#125;</span><br><span class="line">        MultipartBody body = bodybuilder.build();</span><br><span class="line">        return post(url,TYPE_FORM,headerMap,body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: post-&gt;file</span><br><span class="line">     * @Param: [url, headerMap, parametersBody, fileMap]</span><br><span class="line">     * @return: java.lang.String</span><br><span class="line">     * @Date: 2022/4/27</span><br><span class="line">     */</span><br><span class="line">    public static String postFile(String url,Map&lt;String ,String&gt; headerMap,Map&lt;String,String&gt; parametersBody,Map&lt;String,MultipartFile&gt; fileMap)&#123;</span><br><span class="line">        //请求体</span><br><span class="line">        MultipartBody.Builder bodybuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);</span><br><span class="line">        if (!ObjectUtils.isEmpty(parametersBody))&#123;</span><br><span class="line">            parametersBody.forEach(bodybuilder::addFormDataPart);</span><br><span class="line">        &#125;</span><br><span class="line">        //带文件</span><br><span class="line">        if (!ObjectUtils.isEmpty(fileMap))&#123;</span><br><span class="line">            fileMap.forEach((k,v) -&gt;&#123;</span><br><span class="line">                byte[] bytes = new byte[0];</span><br><span class="line">                try &#123;</span><br><span class="line">                    bytes = v.getBytes();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                bodybuilder.addFormDataPart(k,v.getOriginalFilename(),RequestBody.create(MediaType.parse(&quot;image/*&quot;), bytes));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        MultipartBody body = bodybuilder.build();</span><br><span class="line">        return post(url,TYPE_FORM_DATA,headerMap,body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: patch-&gt;json</span><br><span class="line">     * @Param: [url, headerMap, json]</span><br><span class="line">     * @return: java.lang.String</span><br><span class="line">     * @Date: 2022/4/27</span><br><span class="line">     */</span><br><span class="line">    public static String patchJson(String url,Map&lt;String ,String&gt; headerMap,String json)&#123;</span><br><span class="line">        RequestBody body = RequestBody.create(MediaType.parse(TYPE_JSON), json);</span><br><span class="line">        return patch(url,TYPE_JSON,headerMap,body);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** </span><br><span class="line">    * @Description: get-&gt;base64</span><br><span class="line">    * @Param: [url, headerMap, parametersBody]</span><br><span class="line">    * @return: java.lang.String</span><br><span class="line">    * @Date: 2022/4/27</span><br><span class="line">    */</span><br><span class="line">    public static String getRespStream(String url,Map&lt;String ,String&gt; headerMap) &#123;</span><br><span class="line">        //创建客户端</span><br><span class="line">        OkHttpClient client = new OkHttpClient().newBuilder().build();</span><br><span class="line">        //构建请求</span><br><span class="line">        Request.Builder reqBuild = new Request.Builder();</span><br><span class="line">        //请求头</span><br><span class="line">        if (!ObjectUtils.isEmpty(headerMap)) &#123;</span><br><span class="line">            headerMap.forEach(reqBuild::addHeader);</span><br><span class="line">        &#125;</span><br><span class="line">        //组装请求参数</span><br><span class="line">        Request req = reqBuild.url(url).get().build();</span><br><span class="line">        //执行</span><br><span class="line">        Response response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            response = client.newCall(req).execute();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(&quot;发送http-getRespStream请求异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">        int code = response.code();</span><br><span class="line">        if (code != 200) &#123;</span><br><span class="line">            String result = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                result = response.body().string();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] bytes = new byte[0];</span><br><span class="line">        try &#123;</span><br><span class="line">            bytes = response.body().bytes();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //返回base64格式</span><br><span class="line">        String bytesStr = Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">        Map&lt;String, String&gt; resultMap = new HashMap&lt;&gt;();</span><br><span class="line">        resultMap.put(&quot;code&quot;, &quot;0&quot;);</span><br><span class="line">        resultMap.put(&quot;msg&quot;, &quot;request success&quot;);</span><br><span class="line">        resultMap.put(&quot;data&quot;, bytesStr);</span><br><span class="line">        return JSON.toJSONString(resultMap);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * @Description: 拼接参数</span><br><span class="line">    * @Param: [parametersBody]</span><br><span class="line">    * @return: java.lang.String</span><br><span class="line">    * @Date: 2022/4/27</span><br><span class="line">    */</span><br><span class="line">    public static String getNewUrl(String url ,Map&lt;String,String&gt; parametersBody) &#123;</span><br><span class="line">        //遍历map中所有参数到builder</span><br><span class="line">        if (parametersBody != null &amp;&amp; parametersBody.size() &gt; 0) &#123;</span><br><span class="line">            StringBuffer stringBuffer = new StringBuffer(&quot;?&quot;);</span><br><span class="line">            for (String key : parametersBody.keySet()) &#123;</span><br><span class="line">                if (parametersBody.get(key) != null) &#123;//如果参数不是null，就拼接起来</span><br><span class="line">                    stringBuffer.append(&quot;&amp;&quot;);</span><br><span class="line">                    stringBuffer.append(key);</span><br><span class="line">                    stringBuffer.append(&quot;=&quot;);</span><br><span class="line">                    stringBuffer.append(parametersBody.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            url += stringBuffer.toString();</span><br><span class="line">            return url;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description: get</span><br><span class="line">    * @Param: [url, headerMap, parametersBody]</span><br><span class="line">    * @return: java.lang.String</span><br><span class="line">    * @Date: 2022/4/27</span><br><span class="line">    */</span><br><span class="line">    public static String get(String url,Map&lt;String ,String&gt; headerMap)&#123;</span><br><span class="line">        //创建客户端</span><br><span class="line">        OkHttpClient client = new OkHttpClient().newBuilder().build();</span><br><span class="line">        //构建请求</span><br><span class="line">        Request.Builder reqBuild = new Request.Builder();</span><br><span class="line">        //请求头</span><br><span class="line">        if (!ObjectUtils.isEmpty(headerMap))&#123;</span><br><span class="line">            headerMap.forEach(reqBuild::addHeader);</span><br><span class="line">        &#125;</span><br><span class="line">        //组装请求参数</span><br><span class="line">        Request req = reqBuild.url(url).get().build();</span><br><span class="line">        //执行</span><br><span class="line">        Response response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            response = client.newCall(req).execute();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(&quot;发送http-get请求异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回值</span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            result = response.body().string();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description: post</span><br><span class="line">    * @Param: [url, contenType, headerMap, parametersBody, fileMap]</span><br><span class="line">    * @return: java.lang.String</span><br><span class="line">    * @Date: 2022/4/27</span><br><span class="line">    */</span><br><span class="line">    public static String post(String url ,String contenType, Map&lt;String ,String&gt; headerMap, RequestBody body)&#123;</span><br><span class="line">        //创建客户端</span><br><span class="line">        OkHttpClient client = new OkHttpClient().newBuilder().build();</span><br><span class="line">        //构建请求</span><br><span class="line">        Request.Builder reqBuild = new Request.Builder();</span><br><span class="line">        //请求头</span><br><span class="line">        reqBuild.addHeader(&quot;Content-Type&quot;,contenType);</span><br><span class="line">        if (!ObjectUtils.isEmpty(headerMap))&#123;</span><br><span class="line">            headerMap.forEach(reqBuild::addHeader);</span><br><span class="line">        &#125;</span><br><span class="line">        //组装请求参数</span><br><span class="line">        Request req = reqBuild.url(url).method(&quot;POST&quot;, body).build();</span><br><span class="line">        //执行</span><br><span class="line">        Response response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            response = client.newCall(req).execute();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(&quot;发送http-post请求异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回值</span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            result = response.body().string();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description: patch</span><br><span class="line">    * @Param: [url, contenType, headerMap, parametersBody]</span><br><span class="line">    * @return: java.lang.String</span><br><span class="line">    * @Date: 2022/4/27</span><br><span class="line">    */</span><br><span class="line">    public static String patch(String url ,String contenType, Map&lt;String ,String&gt; headerMap, RequestBody body)&#123;</span><br><span class="line">        OkHttpClient client = new OkHttpClient().newBuilder().build();</span><br><span class="line">        //构建请求</span><br><span class="line">        Request.Builder reqBuild = new Request.Builder();</span><br><span class="line">        //请求头</span><br><span class="line">        reqBuild.addHeader(&quot;Content-Type&quot;,contenType);</span><br><span class="line">        if (!ObjectUtils.isEmpty(headerMap))&#123;</span><br><span class="line">            headerMap.forEach(reqBuild::addHeader);</span><br><span class="line">        &#125;</span><br><span class="line">        //组装请求参数</span><br><span class="line">        Request req = reqBuild.url(url).method(&quot;PATCH&quot;, body).build();</span><br><span class="line">        //执行</span><br><span class="line">        Response response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            response = client.newCall(req).execute();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String result = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            result = response.body().string();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OkHttpClientUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static final int READ_TIMEOUT = 100;</span><br><span class="line">    private static final int CONNECT_TIMEOUT = 60;</span><br><span class="line">    private static final int WRITE_TIMEOUT = 60;</span><br><span class="line">    private static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);</span><br><span class="line">    private static final byte[] LOCKER = new byte[0];</span><br><span class="line">    private static OkHttpClientUtil mInstance;</span><br><span class="line">    private final OkHttpClient okHttpClient;</span><br><span class="line"></span><br><span class="line">    private OkHttpClientUtil() &#123;</span><br><span class="line">        OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder();</span><br><span class="line">        // 读取超时</span><br><span class="line">        clientBuilder.readTimeout(READ_TIMEOUT, TimeUnit.SECONDS);</span><br><span class="line">        // 连接超时</span><br><span class="line">        clientBuilder.connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS);</span><br><span class="line">        //写入超时</span><br><span class="line">        clientBuilder.writeTimeout(WRITE_TIMEOUT, TimeUnit.SECONDS);</span><br><span class="line">        okHttpClient = clientBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 单例模式获取 NetUtils</span><br><span class="line">     *</span><br><span class="line">     * @return &#123;@link OkHttpClientUtil&#125;</span><br><span class="line">     */</span><br><span class="line">    public static synchronized OkHttpClientUtil getInstance() &#123;</span><br><span class="line">        if (mInstance == null) &#123;</span><br><span class="line">            synchronized (LOCKER) &#123;</span><br><span class="line">                if (mInstance == null) &#123;</span><br><span class="line">                    mInstance = new OkHttpClientUtil();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * GET，同步方式，获取网络数据</span><br><span class="line">     *</span><br><span class="line">     * @param url 请求地址</span><br><span class="line">     * @return &#123;@link Response&#125;</span><br><span class="line">     */</span><br><span class="line">    public Response getData(String url) &#123;</span><br><span class="line">        // 构造 Request</span><br><span class="line">        Request.Builder builder = new Request.Builder();</span><br><span class="line">        Request request = builder.get().url(url).build();</span><br><span class="line">        // 将 Request 封装为 Call</span><br><span class="line">        Call call = okHttpClient.newCall(request);</span><br><span class="line">        // 执行 Call，得到 Response</span><br><span class="line">        Response response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            response = call.execute();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * POST 请求，同步方式，提交数据</span><br><span class="line">     *</span><br><span class="line">     * @param url        请求地址</span><br><span class="line">     * @param bodyParams 请求参数</span><br><span class="line">     * @return &#123;@link Response&#125;</span><br><span class="line">     */</span><br><span class="line">    public Response postData(String url, Map&lt;String, String&gt; bodyParams) &#123;</span><br><span class="line">        // 构造 RequestBody</span><br><span class="line">        RequestBody body = setRequestBody(bodyParams);</span><br><span class="line">        // 构造 Request</span><br><span class="line">        Request.Builder requestBuilder = new Request.Builder();</span><br><span class="line">        Request request = requestBuilder.post(body).url(url).build();</span><br><span class="line">        // 将 Request 封装为 Call</span><br><span class="line">        Call call = okHttpClient.newCall(request);</span><br><span class="line">        // 执行 Call，得到 Response</span><br><span class="line">        Response response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            response = call.execute();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * GET 请求，异步方式，获取网络数据</span><br><span class="line">     *</span><br><span class="line">     * @param url       请求地址</span><br><span class="line">     * @param myNetCall 回调函数</span><br><span class="line">     */</span><br><span class="line">    public void getDataAsync(String url, final MyNetCall myNetCall) &#123;</span><br><span class="line">        // 构造 Request</span><br><span class="line">        Request.Builder builder = new Request.Builder();</span><br><span class="line">        Request request = builder.get().url(url).build();</span><br><span class="line">        // 将 Request 封装为 Call</span><br><span class="line">        Call call = okHttpClient.newCall(request);</span><br><span class="line">        // 执行 Call</span><br><span class="line">        call.enqueue(new Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;</span><br><span class="line">                myNetCall.failed(call, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;</span><br><span class="line">                myNetCall.success(call, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * POST 请求，异步方式，提交数据</span><br><span class="line">     *</span><br><span class="line">     * @param url        请求地址</span><br><span class="line">     * @param bodyParams 请求参数</span><br><span class="line">     * @param myNetCall  回调函数</span><br><span class="line">     */</span><br><span class="line">    public void postDataAsync(String url, Map&lt;String, String&gt; bodyParams, final MyNetCall myNetCall) &#123;</span><br><span class="line">        // 构造 RequestBody</span><br><span class="line">        RequestBody body = setRequestBody(bodyParams);</span><br><span class="line">        // 构造 Request</span><br><span class="line">        buildRequest(url, myNetCall, body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步 POST 请求，使用 JSON 格式作为参数</span><br><span class="line">     *</span><br><span class="line">     * @param url  请求地址</span><br><span class="line">     * @param json JSON 格式参数</span><br><span class="line">     * @return 响应结果</span><br><span class="line">     * @throws IOException 异常</span><br><span class="line">     */</span><br><span class="line">    public String postJson(String url, String json) throws IOException &#123;</span><br><span class="line">        RequestBody body = RequestBody.create(json, JSON);</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build();</span><br><span class="line">        Response response = okHttpClient.newCall(request).execute();</span><br><span class="line">        if (response.isSuccessful()) &#123;</span><br><span class="line">            return Objects.requireNonNull(response.body()).string();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public String postJson(String url, String json,Headers headerMap) throws IOException &#123;</span><br><span class="line">        RequestBody body = RequestBody.create(json, JSON);</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .headers(headerMap)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build();</span><br><span class="line">        Response response = okHttpClient.newCall(request).execute();</span><br><span class="line">        if (response.isSuccessful()) &#123;</span><br><span class="line">            return Objects.requireNonNull(response.body()).string();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异步 POST 请求，使用 JSON 格式作为参数</span><br><span class="line">     *</span><br><span class="line">     * @param url       请求地址</span><br><span class="line">     * @param json      JSON 格式参数</span><br><span class="line">     * @param myNetCall 回调函数</span><br><span class="line">     * @throws IOException 异常</span><br><span class="line">     */</span><br><span class="line">    public void postJsonAsync(String url, String json, final MyNetCall myNetCall) throws IOException &#123;</span><br><span class="line">        RequestBody body = RequestBody.create(json, JSON);</span><br><span class="line">        // 构造 Request</span><br><span class="line">        buildRequest(url, myNetCall, body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造 POST 请求参数</span><br><span class="line">     *</span><br><span class="line">     * @param bodyParams 请求参数</span><br><span class="line">     * @return &#123;@link RequestBody&#125;</span><br><span class="line">     */</span><br><span class="line">    private RequestBody setRequestBody(Map&lt;String, String&gt; bodyParams) &#123;</span><br><span class="line">        RequestBody body = null;</span><br><span class="line">        FormBody.Builder formEncodingBuilder = new FormBody.Builder();</span><br><span class="line">        if (bodyParams != null) &#123;</span><br><span class="line">            Iterator&lt;String&gt; iterator = bodyParams.keySet().iterator();</span><br><span class="line">            String key = &quot;&quot;;</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                key = iterator.next();</span><br><span class="line">                formEncodingBuilder.add(key, bodyParams.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        body = formEncodingBuilder.build();</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造 Request 发起异步请求</span><br><span class="line">     *</span><br><span class="line">     * @param url       请求地址</span><br><span class="line">     * @param myNetCall 回调函数</span><br><span class="line">     * @param body      &#123;@link RequestBody&#125;</span><br><span class="line">     */</span><br><span class="line">    private void buildRequest(String url, MyNetCall myNetCall, RequestBody body) &#123;</span><br><span class="line">        Request.Builder requestBuilder = new Request.Builder();</span><br><span class="line">        Request request = requestBuilder.post(body).url(url).build();</span><br><span class="line">        // 将 Request 封装为 Call</span><br><span class="line">        Call call = okHttpClient.newCall(request);</span><br><span class="line">        // 执行 Call</span><br><span class="line">        call.enqueue(new Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;</span><br><span class="line">                myNetCall.failed(call, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;</span><br><span class="line">                myNetCall.success(call, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自定义网络回调接口</span><br><span class="line">     */</span><br><span class="line">    public interface MyNetCall &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 请求成功的回调处理</span><br><span class="line">         *</span><br><span class="line">         * @param call     &#123;@link Call&#125;</span><br><span class="line">         * @param response &#123;@link Response&#125;</span><br><span class="line">         * @throws IOException 异常</span><br><span class="line">         */</span><br><span class="line">        void success(Call call, Response response) throws IOException;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 请求失败的回调处理</span><br><span class="line">         *</span><br><span class="line">         * @param call &#123;@link Call&#125;</span><br><span class="line">         * @param e    异常</span><br><span class="line">         */</span><br><span class="line">        void failed(Call call, IOException e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OKHttp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ集群搭建</title>
      <link href="/2022/03/26/RabbitMQ%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/03/26/RabbitMQ%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="LINUX-搭建集群"><a href="#LINUX-搭建集群" class="headerlink" title="LINUX 搭建集群"></a>LINUX 搭建集群</h2><p>修改每台机器的主机名称</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/hostname </span><br></pre></td></tr></table></figure><p>在每台服务器中配置其他服务器 hosts文件，让各个节点都能互相识别对方</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br></pre></td></tr></table></figure><p>下图效果</p><p><img src="https://liang-git.oss-cn-beijing.aliyuncs.com/hexo/rabbitmq%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE.png" alt=""></p><p>确保各个节点的cookie文件使用的是同一个值 {@node2[服务主机名称] }</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp /var/ib/rabbitmq/.erlang.cookie root@node2:/ar/ib/rabbitmg/.erlang.cookie I</span><br></pre></td></tr></table></figure><p>启动RabbitMQ服务,顺带启动Erlang虚拟机和RbbitMQ应用服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure><p>在其他主机执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_ app # 关闭服务  (rabbitmqctl stop会将Erlang 虚拟机关闭, rabbitmqct! stop. app只关闭RabbitMQ服务)</span><br><span class="line">rabbitmqctl reset # 重置</span><br><span class="line">rabbitmqctl join. _cluster rabbit@node1 #[主机名称] #加入到第一台主机中</span><br><span class="line">rabbitmqctl start, app(只启动应用服务)</span><br></pre></td></tr></table></figure><p>查看集群状态</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl cluster_ status</span><br></pre></td></tr></table></figure><p>解除集群节点(node2和node3机器分别执行)【脱离集群】</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_ _app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqct! start_ app</span><br><span class="line">rabbitmgctl cluster_ status</span><br><span class="line">rabbitmgctl forget. _cluster node rabbit@node2(node1机器上执行) # node1主机忘掉node2主机</span><br></pre></td></tr></table></figure><h2 id="DOCKER-搭建集群"><a href="#DOCKER-搭建集群" class="headerlink" title="DOCKER 搭建集群"></a>DOCKER 搭建集群</h2><p>版本为 <strong>rabbitmq:3.7-management</strong> </p><ul><li>执行以下命名创建docker镜像</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname rabbitmq01 --name rabbitmqCluster01 -p 15672:15672 -p 5672:5672 -p 1883:1883 -e RABBITMQ_ERLANG_COOKIE=&#x27;rabbitmqCookie&#x27; rabbitmq:3.7-management</span><br><span class="line"></span><br><span class="line">docker run -d --hostname rabbitmq02 --name rabbitmqCluster02 -p 15673:15672 -p 5673:5672 -p 1884:1883 -e RABBITMQ_ERLANG_COOKIE=&#x27;rabbitmqCookie&#x27; --link rabbitmqCluster01:rabbitmq01 rabbitmq:3.7-management</span><br><span class="line"></span><br><span class="line">docker run -d --hostname rabbitmq03 --name rabbitmqCluster03 -p 15674:15672 -p 5674:5672 -p 1885:1883 -e RABBITMQ_ERLANG_COOKIE=&#x27;rabbitmqCookie&#x27; --link rabbitmqCluster01:rabbitmq01 --link rabbitmqCluster02:rabbitmq02  rabbitmq:3.7-management</span><br></pre></td></tr></table></figure><p>主要参数：</p><ul><li>-p 15672:15672 management 界面管理访问端口</li><li>-p 5672:5672 amqp 访问端口</li><li>-p 1883:1883 mqtt访问端口  也可以把容器里的数据共享到宿主机上</li><li>-v /home/soft/rabbitmqcluster/rabbitmq01:/var/lib/rabbitmq</li><li>–link 容器之间连接<br>Erlang Cookie 值必须相同，也就是一个集群内 RABBITMQ_ERLANG_COOKIE 参数的值必须相同。因为 RabbitMQ 是用Erlang实现的，Erlang Cookie 相当于不同节点之间通讯的密钥，Erlang节点通过交换 Erlang Cookie 获得认证。</li></ul><p>容器节点加入集群</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入第一个容器</span><br><span class="line">docker exec -it rabbitmqCluster01 bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入第二个容器</span><br><span class="line">docker exec -it rabbitmqCluster02 bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line"></span><br><span class="line">加入集群</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbitmq01</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入第三个容器</span><br><span class="line">docker exec -it rabbitmqCluster03 bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line"></span><br><span class="line">加入集群</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbitmq01</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>–ram 表示设置为内存节点，忽略此参数默认为磁盘节点。该配置启动了3个节点，1个磁盘节点和2个内存节点。</p><h3 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h3><h4 id="登录rabbitmq管理页面-——-gt-Admin-——-gt-Policies-——-gt-Add-update-a-policy"><a href="#登录rabbitmq管理页面-——-gt-Admin-——-gt-Policies-——-gt-Add-update-a-policy" class="headerlink" title="登录rabbitmq管理页面 ——&gt; Admin ——&gt; Policies ——&gt; Add / update a policy"></a>登录rabbitmq管理页面 ——&gt; Admin ——&gt; Policies ——&gt; Add / update a policy</h4><p><img src="https://liang-git.oss-cn-beijing.aliyuncs.com/hexo/%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png" alt=""></p><h4 id="使用命令创建"><a href="#使用命令创建" class="headerlink" title="使用命令创建"></a>使用命令创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入容器</span><br><span class="line">docker exec -it rabbitmqCluster01 bash</span><br><span class="line"></span><br><span class="line"># 创建策略</span><br><span class="line">rabbitmqctl set_policy ha-all &quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">rabbitmqctl set_policy-p/ha-all&quot;^&quot;&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">rabbitmqctl set_policy-p/ha-all&quot;^message&quot;&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line"># “^message” 这个规则要根据自己修改，这个是指同步“message”开头的队列名称，我们配置时使用的应用于所有队列，所以表达式为“^”</span><br><span class="line">     </span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://liang-git.oss-cn-beijing.aliyuncs.com/hexo/rabbitmq%E9%9B%86%E7%BE%A4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
          <category> 集群搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付宝支付接口</title>
      <link href="/2022/03/11/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/03/11/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>官网：</strong> <a href="https://open.alipay.com/">网页&amp;移动应用</a>  </p><span id="more"></span><h2 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h2><h3 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h3><ol><li><p>前端请求访问控制层 “/alipay” 接口</p><p> 1.1 初始化支付 DefaultAlipayClient 对象</p><p> 1.2 使用 AlipayTradePagePayRequest（网页支付请求对象） 对象设置请求参数</p><ul><li><p>设置返回地址和异步返回地址</p></li><li><p>设置业务内容（json）</p><p>1.3 获取请求体的html代码</p><p>1.4 响应请求体后通过</p></li></ul></li><li><p>接受返回结果<br> 2.1 支付宝支付后会调用返回接口（同步接口异常会调用异步返回接口）<br> 2.2 通过Map获取参数<br><strong>2.3 验签 AlipaySignature 对象的 rsaCheckV1() 验签</strong>  </p><ul><li><strong>验证成功 执行自定义的代码逻辑</strong></li><li><strong>验证失败 响应错误信息</strong></li></ul></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>引入依赖</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.13.58.ALL&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>导入配置类(将准备的参数赋值给指定常量)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* *</span><br><span class="line"> *类名：AlipayConfig</span><br><span class="line"> *功能：基础配置类</span><br><span class="line"> *详细：设置帐户有关信息及返回路径</span><br><span class="line"> *说明：</span><br><span class="line"> *以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。</span><br><span class="line"> *该代码仅供学习和研究支付宝接口使用，只是提供一个参考。</span><br><span class="line"> */</span><br><span class="line">public class AlipayConfig &#123;</span><br><span class="line"></span><br><span class="line">    // 商户appid , 收款账号既是您的APPID对应支付宝账号</span><br><span class="line">    public static String APPID = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    // 私钥 pkcs8格式的</span><br><span class="line">    public static String RSA_PRIVATE_KEY = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    // 服务器异步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问</span><br><span class="line">    public static String notify_url = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    // 页面跳转同步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 商户可以自定义同步跳转地址</span><br><span class="line">    public static String return_url = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    // 请求网关地址</span><br><span class="line">    public static String URL = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    // 编码</span><br><span class="line">    public static String CHARSET = &quot;UTF-8&quot;;</span><br><span class="line"></span><br><span class="line">    // 返回格式</span><br><span class="line">    public static String FORMAT = &quot;json&quot;;</span><br><span class="line"></span><br><span class="line">    // 支付宝公钥 ， 查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。</span><br><span class="line">    public static String ALIPAY_PUBLIC_KEY = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    // 日志记录目录</span><br><span class="line">    public static String log_path = &quot;/log&quot;;</span><br><span class="line"></span><br><span class="line">    // 签名方式 RSA2</span><br><span class="line">    public static String SIGNTYPE = &quot;RSA2&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>日志工具类</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class LogFile &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 写日志，方便测试（看网站需求，也可以改成把记录存入数据库）</span><br><span class="line">     * @param sWord 要写入日志里的文本内容</span><br><span class="line">     */</span><br><span class="line">    public static void logResult(String sWord) &#123;</span><br><span class="line">        FileWriter writer = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            writer = new FileWriter(AlipayConfig.log_path + &quot;alipay_log_&quot; + System.currentTimeMillis()+&quot;.txt&quot;);</span><br><span class="line">            writer.write(sWord);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (writer != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>官方demo <ul><li>JSP代码</li></ul></li></ul><button onclick="window.open('/alipay/notify_url.jsp')">手机网站2.0支付异步通知</button><button onclick="window.open('/alipay/return_url.jsp')">手机网站2.0支付同步通知</button><button onclick="window.open('/alipay/wappay/pay.jsp')">手机网站2.0支付(接口名：alipay.trade.wap.pay)</button><button onclick="window.open('/alipay/wappay/query.jsp')">手机网站2.0订单查询 (接口名：alipay.trade.query)</button><button onclick="window.open('/alipay/wappay/refund.jsp')">手机网站2.0订单退款  (接口名：alipay.trade.refund)</button>    <button onclick="window.open('/alipay/wappay/refundquery.jsp')">手机网站2.0订单退款查询(接口名：alipay.trade.fastpay.refund.query)</button><button onclick="window.open('/alipay/wappay/downloadurl.jsp')">手机网站2.0账单下载(接口名：alipay.data.dataservice.bill.downloadurl.query)</button><ul><li>SDK使用</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.alipay.api.AlipayApiException;</span><br><span class="line">import com.alipay.api.AlipayClient;</span><br><span class="line">import com.alipay.api.DefaultAlipayClient;</span><br><span class="line">import com.alipay.api.domain.AlipayTradeWapPayModel;</span><br><span class="line">import com.alipay.api.internal.util.AlipaySignature;</span><br><span class="line">import com.alipay.api.request.AlipayTradePagePayRequest;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liangbaichuan</span><br><span class="line"> * @Title: AlipayController</span><br><span class="line"> * @create: 2018-03-11 11:14</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class AlipayController &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(AlipayController.class);</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/alipay&quot;)</span><br><span class="line">    public String alipay(HttpServletRequest request) throws UnsupportedEncodingException &#123;</span><br><span class="line">        // 根据订单编号查询订单表获取订单金额</span><br><span class="line"></span><br><span class="line">        // 初始化AlipayClient</span><br><span class="line">        AlipayClient alipayClient = new DefaultAlipayClient(</span><br><span class="line">                AlipayConfig.URL,</span><br><span class="line">                AlipayConfig.APPID,</span><br><span class="line">                AlipayConfig.RSA_PRIVATE_KEY,</span><br><span class="line">                AlipayConfig.FORMAT,</span><br><span class="line">                AlipayConfig.CHARSET,</span><br><span class="line">                AlipayConfig.ALIPAY_PUBLIC_KEY,</span><br><span class="line">                AlipayConfig.SIGNTYPE</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 设置请求参数</span><br><span class="line">        AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();</span><br><span class="line">        // 设置同步地址</span><br><span class="line">        alipayRequest.setReturnUrl(AlipayConfig.return_url);</span><br><span class="line">        // 设置异步通知地址</span><br><span class="line">        alipayRequest.setNotifyUrl(AlipayConfig.notify_url);</span><br><span class="line"></span><br><span class="line">        // 商户订单号，商户网站订单系统中唯一订单号，必填</span><br><span class="line">        String out_trade_no = new String(request.getParameter(&quot;WIDout_trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line">        // 订单名称，必填</span><br><span class="line">        String subject = new String(request.getParameter(&quot;WIDsubject&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(subject);</span><br><span class="line">        // 付款金额，必填</span><br><span class="line">        String total_amount=new String(request.getParameter(&quot;WIDtotal_amount&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line">        // 商品描述，可空</span><br><span class="line">        String body = new String(request.getParameter(&quot;WIDbody&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line">        // 超时时间 可空</span><br><span class="line">        String timeout_express=&quot;2m&quot;;</span><br><span class="line">        // 销售产品码 必填</span><br><span class="line">        String product_code=&quot;QUICK_WAP_WAY&quot;;</span><br><span class="line"></span><br><span class="line">        // 封装请求支付信息</span><br><span class="line">        AlipayTradeWapPayModel model=new AlipayTradeWapPayModel();</span><br><span class="line">        model.setOutTradeNo(out_trade_no);</span><br><span class="line">        model.setSubject(subject);</span><br><span class="line">        model.setTotalAmount(total_amount);</span><br><span class="line">        model.setBody(body);</span><br><span class="line">        model.setTimeoutExpress(timeout_express);</span><br><span class="line">        model.setProductCode(product_code);</span><br><span class="line">        alipayRequest.setBizModel(model);</span><br><span class="line"></span><br><span class="line">        // 请求</span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            result = alipayClient.pageExecute(alipayRequest).getBody();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; catch (AlipayApiException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        // 输出</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/returnResult&quot;)</span><br><span class="line">    public String returnResult(HttpServletRequest request) throws UnsupportedEncodingException &#123;</span><br><span class="line">        log.info(&quot;收到同步回调&quot;);</span><br><span class="line"></span><br><span class="line">        //获取支付宝GET过来反馈信息</span><br><span class="line">        Map&lt;String,String&gt; params = new HashMap&lt;String,String&gt;();</span><br><span class="line">        Map requestParams = request.getParameterMap();</span><br><span class="line">        for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">            String name = (String) iter.next();</span><br><span class="line">            String[] values = (String[]) requestParams.get(name);</span><br><span class="line">            String valueStr = &quot;&quot;;</span><br><span class="line">            for (int i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">                valueStr = (i == values.length - 1) ? valueStr + values[i]</span><br><span class="line">                        : valueStr + values[i] + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //乱码解决，这段代码在出现乱码时使用。如果mysign和sign不相等也可以使用这段代码转化</span><br><span class="line">            valueStr = new String(valueStr.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);</span><br><span class="line">            params.put(name, valueStr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以下仅供参考)//</span><br><span class="line">        //商户订单号</span><br><span class="line">        String out_trade_no = new String(request.getParameter(&quot;out_trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        //支付宝交易号</span><br><span class="line"></span><br><span class="line">        String trade_no = new String(request.getParameter(&quot;trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line">        //获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以上仅供参考)//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //计算得出通知验证结果</span><br><span class="line">        //boolean AlipaySignature.rsaCheckV1(Map&lt;String, String&gt; params, String publicKey, String charset, String sign_type)</span><br><span class="line">        boolean verify_result = false;</span><br><span class="line">        try &#123;</span><br><span class="line">             verify_result = AlipaySignature.rsaCheckV1(params, AlipayConfig.ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, &quot;RSA2&quot;);</span><br><span class="line">        &#125; catch (AlipayApiException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (verify_result)&#123; //验证成功</span><br><span class="line">            return &quot;&lt;script&gt;location.href=&#x27;success.html&#x27;&lt;/script&gt;&quot;;</span><br><span class="line">        &#125;else&#123; //验证失败</span><br><span class="line">            return &quot;&lt;script&gt;location.href=&#x27;error.html&#x27;&lt;/script&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/notifyResult&quot;)</span><br><span class="line">    public String notifyResult(HttpServletRequest request) throws UnsupportedEncodingException &#123;</span><br><span class="line">        //获取支付宝POST过来反馈信息</span><br><span class="line">        Map&lt;String,String&gt; params = new HashMap&lt;String,String&gt;();</span><br><span class="line">        Map requestParams = request.getParameterMap();</span><br><span class="line">        for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">            String name = (String) iter.next();</span><br><span class="line">            String[] values = (String[]) requestParams.get(name);</span><br><span class="line">            String valueStr = &quot;&quot;;</span><br><span class="line">            for (int i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">                valueStr = (i == values.length - 1) ? valueStr + values[i]</span><br><span class="line">                        : valueStr + values[i] + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //乱码解决，这段代码在出现乱码时使用。如果mysign和sign不相等也可以使用这段代码转化</span><br><span class="line">            //valueStr = new String(valueStr.getBytes(&quot;ISO-8859-1&quot;), &quot;gbk&quot;);</span><br><span class="line">            params.put(name, valueStr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以下仅供参考)//</span><br><span class="line">        //商户订单号</span><br><span class="line"></span><br><span class="line">        String out_trade_no = new String(request.getParameter(&quot;out_trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line">        //支付宝交易号</span><br><span class="line"></span><br><span class="line">        String trade_no = new String(request.getParameter(&quot;trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        //交易状态</span><br><span class="line">        String trade_status = new String(request.getParameter(&quot;trade_status&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        //获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以上仅供参考)//</span><br><span class="line">        //计算得出通知验证结果</span><br><span class="line">        //boolean AlipaySignature.rsaCheckV1(Map&lt;String, String&gt; params, String publicKey, String charset, String sign_type)</span><br><span class="line">        boolean verify_result  = false ;</span><br><span class="line">        try &#123;</span><br><span class="line">            verify_result = AlipaySignature.rsaCheckV1(params, AlipayConfig.ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, &quot;RSA2&quot;);</span><br><span class="line">        &#125; catch (AlipayApiException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (verify_result)&#123; //验证成功</span><br><span class="line"></span><br><span class="line">            //——请根据您的业务逻辑来编写程序（以下代码仅作参考）——</span><br><span class="line">            if(trade_status.equals(&quot;TRADE_FINISHED&quot;))&#123;</span><br><span class="line">                //判断该笔订单是否在商户网站中已经做过处理</span><br><span class="line">                //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序</span><br><span class="line">                //请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的</span><br><span class="line">                //如果有做过处理，不执行商户的业务程序</span><br><span class="line"></span><br><span class="line">                //注意：</span><br><span class="line">                //如果签约的是可退款协议，退款日期超过可退款期限后（如三个月可退款），支付宝系统发送该交易状态通知</span><br><span class="line">                //如果没有签约可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。</span><br><span class="line">            &#125; else if (trade_status.equals(&quot;TRADE_SUCCESS&quot;))&#123;</span><br><span class="line">                //判断该笔订单是否在商户网站中已经做过处理</span><br><span class="line">                //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序</span><br><span class="line">                //请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的</span><br><span class="line">                //如果有做过处理，不执行商户的业务程序</span><br><span class="line"></span><br><span class="line">                //注意：</span><br><span class="line">                //如果签约的是可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。</span><br><span class="line">            &#125;</span><br><span class="line">            return  &quot;&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置类中的常量可以通过配置文件注入</li></ul>]]></content>
      
      
      <categories>
          
          <category> 支付宝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客搭建</title>
      <link href="/2021/03/10/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/03/10/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v#查看node版本</span><br><span class="line">npm -v#查看npm版本</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装淘宝-CNPM"><a href="#安装淘宝-CNPM" class="headerlink" title="安装淘宝 CNPM"></a>安装淘宝 CNPM</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org#安装淘宝的cnpm 管理器</span><br><span class="line">cnpm -v#查看cnpm版本</span><br></pre></td></tr></table></figure><h3 id="安装-HEXO-框架"><a href="#安装-HEXO-框架" class="headerlink" title="安装 HEXO 框架"></a>安装 HEXO 框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli    #安装hexo框架</span><br><span class="line">hexo -v#查看hexo版本</span><br></pre></td></tr></table></figure><h3 id="创建-blog"><a href="#创建-blog" class="headerlink" title="创建 blog"></a>创建 blog</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir blog#创建blog目录</span><br><span class="line">cd blog #进入blog目录</span><br><span class="line">sudo hexo init #生成博客 初始化博客</span><br><span class="line">hexo s#启动本地博客服务</span><br><span class="line">http://localhost:4000/#本地访问地址</span><br></pre></td></tr></table></figure><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot;  #创建新的文章  &quot;&quot;里面的为blog名称</span><br></pre></td></tr></table></figure><h3 id="返回blog目录"><a href="#返回blog目录" class="headerlink" title="返回blog目录"></a>返回blog目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean #清理</span><br><span class="line">hexo g #生成</span><br></pre></td></tr></table></figure><h3 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h3><p><img src="/img/hexo_gitHob.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YourGithubName.github.io</span><br></pre></td></tr></table></figure></p><h3 id="安装git部署插件"><a href="#安装git部署插件" class="headerlink" title="安装git部署插件"></a>安装git部署插件</h3><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件</span><br></pre></td></tr></table></figure></h2><h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"> repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d#部署到Github仓库里</span><br><span class="line">https://YourGithubName.github.io/  #访问这个地址可以查看博客</span><br></pre></td></tr></table></figure><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia  #下载yilia主题到本地</span><br></pre></td></tr></table></figure><p>修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><h3 id="Hexo-三连"><a href="#Hexo-三连" class="headerlink" title="Hexo 三连"></a>Hexo 三连</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean #清理</span><br><span class="line">hexo g #生成</span><br><span class="line">hexo s #运行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c#清理一下</span><br><span class="line">hexo g#生成</span><br><span class="line">hexo d#部署到远程Github仓库</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 如何保证消息的可靠传输</title>
      <link href="/2020/07/11/RabbitMQ%20%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
      <url>/2020/07/11/RabbitMQ%20%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>在RabbitMQ中，一个消息从产生到被消费大致会经过三个步骤，生产者生产消息，消息投递到RabbitMQ，RabbitMQ再将消息推送到消费者（或消费者拉取），最终消费者将这条消息成功消费。消息的可靠传输，就是确保消息能够百分百从生产者发送到服务器，在从服务器发送到消费者。</p><p>所以消息丢失也可以划分为三种情况——生产者、消息队列、消费者。</p><span id="more"></span><h4 id="生产者投递消息失败"><a href="#生产者投递消息失败" class="headerlink" title="生产者投递消息失败"></a>生产者投递消息失败</h4><h5 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h5><p>使用 RabbitMQ 的事务功能，此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务 channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务 channel.txCommit。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">`<span class="comment">// 开启事务`</span></span><br><span class="line">`channel.txSelect();`</span><br><span class="line">`<span class="keyword">try</span> &#123;`</span><br><span class="line">    `<span class="comment">// 发送消息`</span></span><br><span class="line">`&#125; <span class="keyword">catch</span>(Exception e) &#123;`</span><br><span class="line">    `channel.txRollback();`</span><br><span class="line">`<span class="comment">// 重发消息`</span></span><br><span class="line">`&#125;`</span><br><span class="line">`<span class="comment">// 提交事务`</span></span><br><span class="line">`channel.txCommit();`</span><br></pre></td></tr></table></figure><p>事务机制可以确保生产者投递消息成功，但是这种方式有比较大的缺点，太耗性能。</p><h5 id="confirm机制"><a href="#confirm机制" class="headerlink" title="confirm机制"></a>confirm机制</h5><p>要确保 RabbitMQ 生产者的消息正确投递，可以开启 confirm 模式，在生产者端设置开启 confirm 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ACK 消息，告诉你说这个消息。</p><p>如果 RabbitMQ 没能处理这个消息，会回调你一个 nack 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.confirmSelect(); <span class="comment">//将信道置为 publisher confirm 模式</span></span><br><span class="line">    <span class="comment">// 之后正常发送消息</span></span><br><span class="line">    channel.basicPushlish(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;routingKey&quot;</span>, <span class="literal">null</span>, </span><br><span class="line">                          <span class="string">&quot;publisher confirm test&quot;</span>.getBytes());</span><br><span class="line">    <span class="keyword">if</span> (!channel.waitFormConfirms()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Send message failed&quot;</span>);</span><br><span class="line">    <span class="comment">// do something else...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收之后会异步回调你一个接口通知你这个消息接收到了。</p><p>所以一般生产者到 RabbitMQ 这块避免数据丢失，会采用 confirm 机制更多些。</p><h5 id="消息队列自身丢失"><a href="#消息队列自身丢失" class="headerlink" title="消息队列自身丢失"></a>消息队列自身丢失</h5><p>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</p><p>设置持久化有两个步骤：</p><ul><li><strong>创建 queue 的时候将其设置为持久化</strong> </li></ul><p>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是不会持久化 queue 里的数据。</p><ul><li><strong>发送消息时将消息的 deliveryMode 设置为 2</strong></li></ul><p>就是将消息设置为持久化，此时 RabbitMQ 就会将消息持久化到磁盘上去。</p><p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p><p>同时持久化也可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ACK，你也是可以自己重发的。</p><p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存中的数据丢失。</p><h5 id="消费者宕机"><a href="#消费者宕机" class="headerlink" title="消费者宕机"></a>消费者宕机</h5><p>对于消费者端所产生的情况就是：消费者成功接收到消息，但是还未将消息处理完毕就宕机了。针对这种情况，可以利用 RabbitMQ 提供的<strong>消息确认机制</strong>。</p><p>为了保证消息从队列可靠地到达消费者，RabbitMQ 提供了消息确认机制（message acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数：</p><ul><li><p>当 autoAck 等于 true 时，RabbitMQ 会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费到了这些消息；</p></li><li><p>当 autoAck 等于 false 时，RabbitMQ 会等待消费者显示地回复确认信号后才从内存（后者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。</p></li></ul><p>所以对于消费者可能发生宕机地情况，我们可以将 autoAck 参数置为 false，消费者就有足够的时间处理这条消息，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为 RabbitMQ 会一直等待并且持有这条消息，直到消费者显示调用 Basic.Ack 命令为止。</p><p>当 autoAck 参数设置为 false，对于 RabbitMQ 服务端而言，队列中的消息分成了两个部分：一部分是等待投递给消费者的消息，另一部分是已经投递给消费者，但是还没有收到消费者确认信号的消息。如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也可能还是原来的那个消费者。</p><p><a href="https://blog.csdn.net/Allen_Adolph/article/details/109055174">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
          <category> 可靠传输 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ发布确认</title>
      <link href="/2020/03/22/RabbitMQ%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4/"/>
      <url>/2020/03/22/RabbitMQ%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="消息确认机制-Confirm模式"><a href="#消息确认机制-Confirm模式" class="headerlink" title="消息确认机制(Confirm模式)"></a>消息确认机制(Confirm模式)</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li><p><strong>通过信道将生产者设置队列持久化</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME,true,false,false,null);</span><br></pre></td></tr></table></figure></li><li><p><strong>通过信道将生产者设置队列的消息持久化</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageProperties.PERSISTENT_TEXT_PLAIN(持久化)</span><br><span class="line">channel.basicPublish(exchange,queue, MessageProperties.PERSISTENT_TEXT_PLAIN,message);</span><br></pre></td></tr></table></figure></li></ul><h3 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: yiLiang</span><br><span class="line"> * @Title: RabbitMQUtils</span><br><span class="line"> * 连接工厂创建信道</span><br><span class="line"> */</span><br><span class="line">public class RabbitMQUtils &#123;</span><br><span class="line"></span><br><span class="line">    // 队列的名称</span><br><span class="line">    public static final String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line">    public static final String TASK_QUEUE_NAME = &quot;ack_queue&quot;;</span><br><span class="line"></span><br><span class="line">    public static Channel getChannel()&#123;</span><br><span class="line">        // 创建一个连接工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        // 工厂IP 连接RabbitMQ的队列</span><br><span class="line">        factory.setHost(&quot;47.95.214.111&quot;);</span><br><span class="line">        // 设置用户名</span><br><span class="line">        factory.setUsername(&quot;guest&quot;);</span><br><span class="line">        // 密码</span><br><span class="line">        factory.setPassword(&quot;guest&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建连接</span><br><span class="line">        try &#123;</span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            // 获取信道</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            return channel;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 模拟发送1000条消息</span><br><span class="line">public static Integer MESSAGE_COUNT = 1000;</span><br></pre></td></tr></table></figure><h4 id="单个确认"><a href="#单个确认" class="headerlink" title="单个确认"></a>单个确认</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 单个确认</span><br><span class="line">   * 1000条耗时大约 722ms(毫秒)</span><br><span class="line">*/</span><br><span class="line">public static void publicMessageIndividually() throws Exception &#123;</span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    // 队列声明</span><br><span class="line">    String queueName = UUID.randomUUID().toString(); // 随机定义</span><br><span class="line">    channel.queueDeclare(queueName,true,false,false,null);</span><br><span class="line">    // 开启发布确认</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    // 记录开始时间</span><br><span class="line">    long beginTime = System.currentTimeMillis();</span><br><span class="line">    for (Integer i = 0; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + &quot;&quot;;</span><br><span class="line">        // 发送消息</span><br><span class="line">        channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        // 单个消息发布确认</span><br><span class="line">        boolean result = channel.waitForConfirms();</span><br><span class="line">        // result = true (发送成功)</span><br><span class="line">    &#125;</span><br><span class="line">    // 记录结束时间</span><br><span class="line">    long endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;发布耗时：&quot; + (endTime-beginTime) + &quot;ms(毫秒)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量确认"><a href="#批量确认" class="headerlink" title="批量确认"></a>批量确认</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 批量确认</span><br><span class="line">   * 1000条耗时大约 147ms(毫秒)</span><br><span class="line">*/</span><br><span class="line">public static void publicMessageBatch() throws Exception&#123;</span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    // 队列声明</span><br><span class="line">    String queueName = UUID.randomUUID().toString(); // 随机定义</span><br><span class="line">    channel.queueDeclare(queueName,true,false,false,null);</span><br><span class="line">    // 开启发布确认</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    // 记录开始时间</span><br><span class="line">    long beginTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    // 设置批量确认的长度</span><br><span class="line">    Integer batchSize = 100 ;</span><br><span class="line"></span><br><span class="line">    for (Integer i = 0; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + &quot;&quot;;</span><br><span class="line">        // 发送消息</span><br><span class="line">        channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        // 判断达到 100 条消息时，批量确认一个</span><br><span class="line">        if (i%batchSize == 0)&#123;</span><br><span class="line">            // 发布确认</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 记录结束时间</span><br><span class="line">    long endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;发布耗时：&quot; + (endTime-beginTime) + &quot;ms(毫秒)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步确认"><a href="#异步确认" class="headerlink" title="异步确认"></a>异步确认</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 异步确认</span><br><span class="line">   * 1000条耗时大约 62ms(毫秒)</span><br><span class="line">*/</span><br><span class="line">public static void publicMessageAsync()throws Exception&#123;</span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    // 队列声明</span><br><span class="line">    String queueName = UUID.randomUUID().toString(); // 随机定义</span><br><span class="line">    channel.queueDeclare(queueName,true,false,false,null);</span><br><span class="line">    // 开启发布确认</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    // 记录开始时间</span><br><span class="line">    long beginTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">       * ConfirmCallback</span><br><span class="line">       * 参数详解</span><br><span class="line">            * 1.消息的标识</span><br><span class="line">            * 2.是否批量确认</span><br><span class="line">    */</span><br><span class="line">    // 消息确认成功 回调函数</span><br><span class="line">    ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    // 消息确认失败 回调函数</span><br><span class="line">    ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;未确认的消息：&quot;+ deliveryTag);</span><br><span class="line">    &#125;;</span><br><span class="line">    /**</span><br><span class="line">       * 参数详解</span><br><span class="line">            * 1.消息确认成功</span><br><span class="line">            * 2.消息确认失败</span><br><span class="line">    */</span><br><span class="line">    // 准备消息的监听器 （监听消息发送失败与否） &#123;异步通知&#125;</span><br><span class="line">    channel.addConfirmListener(ackCallback, nackCallback);</span><br><span class="line"></span><br><span class="line">    // 批量发布</span><br><span class="line">    for (Integer i = 0; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + &quot;&quot;;</span><br><span class="line">        // 发送消息</span><br><span class="line">        channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 记录结束时间</span><br><span class="line">    long endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;发布耗时：&quot; + (endTime-beginTime) + &quot;ms(毫秒)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理异步未确认的消息"><a href="#处理异步未确认的消息" class="headerlink" title="处理异步未确认的消息"></a>处理异步未确认的消息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 处理异步未确认消息</span><br><span class="line">*/</span><br><span class="line">public static void ConcurrentLinkedQueue()&#123;</span><br><span class="line">    // 将未确认消息放于一个基于内存的能被发布线下访问的队列</span><br><span class="line">    // ConcurrentLinkedQueue (并发链入式队列)</span><br><span class="line"></span><br><span class="line">    // 1.在发送消息时记录消息</span><br><span class="line">    // 2.在确认消息回调函数中删除确认的消息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 在如上确认消息中的开启发布确认下添加</span><br><span class="line">    /**</span><br><span class="line">       * 线程安全有序的哈希表，适用于高并发的情况下</span><br><span class="line">       * &lt; 消息序号, 消息类型 &gt; ( &lt;key, value&gt; )</span><br><span class="line">            * 1.可以轻松的将序号与消息进行关联</span><br><span class="line">            * 2.轻松删除条码</span><br><span class="line">            * 3.支持高并发（多线程）</span><br><span class="line">    */</span><br><span class="line">    ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfig = new ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 记录消息</span><br><span class="line">    // outstandingConfig.put(channel.getNextPublishSeqNo(),message);</span><br><span class="line"></span><br><span class="line">    // 删除已经确认的消息</span><br><span class="line">        // 判断是否为批量确认消息</span><br><span class="line">    /*</span><br><span class="line">    if (multiple)&#123;</span><br><span class="line">        ConcurrentNavigableMap&lt;Long, String&gt; headMap = outstandingConfig.headMap(deliveryTag);</span><br><span class="line">        headMap.clear();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        outstandingConfig.remove(deliveryTag);</span><br><span class="line">    &#125;</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
          <category> 发布确认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的基本使用</title>
      <link href="/2020/03/20/RabbitMQ%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/20/RabbitMQ%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 队列名称</span><br><span class="line">public static final String QUEUE_NAME = &quot;hello&quot;;</span><br></pre></td></tr></table></figure><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 发消息</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个连接工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        // 工厂IP 连接RabbitMQ的队列</span><br><span class="line">        factory.setHost(&quot;47.95.214.111&quot;);</span><br><span class="line">        // 设置用户名</span><br><span class="line">        factory.setUsername(&quot;guest&quot;);</span><br><span class="line">        // 密码</span><br><span class="line">        factory.setPassword(&quot;guest&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建连接</span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">            // 获取信道</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            /**</span><br><span class="line">               * 声明一个队列</span><br><span class="line">               * 参数详解</span><br><span class="line">                   * 1.队列名称</span><br><span class="line">                   * 2.队列消息是否持久化（存放磁盘中）（默认消息存储在内存中）</span><br><span class="line">                   * 3.该队列是否只供一个消费者消费 (false 只能一个消费者消费 true 可以多个消费者消费)</span><br><span class="line">                   * 4.是否自动删除 （最后一个消费者断开连接以后 false 否 true 自动删除）</span><br><span class="line">                   * 5. 其他参数（延迟、死信）</span><br><span class="line">               * 持久化： durable：true(持久) false(非持久)</span><br><span class="line">            */</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME,true,false,false,null);</span><br><span class="line">            // 发布确认</span><br><span class="line">            channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">            // 发送消息</span><br><span class="line">            String message = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">               * 发送消息</span><br><span class="line">               * 参数详解</span><br><span class="line">                    * 1.发送到的交换机</span><br><span class="line">                    * 2.路由的key（队列的名称）</span><br><span class="line">                    * 3.其他参数 (可以设置生产者消息持久化&#123;保存在磁盘中&#125;MessageProperties.PERSISTENT_TEXT_PLAIN)</span><br><span class="line">                    * 4.消息体</span><br><span class="line">           */</span><br><span class="line">            channel.basicPublish(&quot;&quot;,QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(&quot;消息发送成功&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 接收消息</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 创建一个连接工厂</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    // 工厂IP 连接RabbitMQ的队列</span><br><span class="line">    factory.setHost(&quot;47.95.214.111&quot;);</span><br><span class="line">    // 设置用户名</span><br><span class="line">    factory.setUsername(&quot;guest&quot;);</span><br><span class="line">    // 密码</span><br><span class="line">    factory.setPassword(&quot;guest&quot;);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 获取信道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 不公布分发(设置于消费者中)</span><br><span class="line">        // prefetchCount 可以设置预取值（因服务器性能设置）</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">        // 接收消息的回调</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag,message) -&gt;&#123;</span><br><span class="line">            System.out.println(new String(message.getBody()));</span><br><span class="line">            /**</span><br><span class="line">             * 手动应答</span><br><span class="line">             * 参数详解</span><br><span class="line">                 * 1.消息的标识 tag</span><br><span class="line">                 * 2.是否批量应答  false:不批量 true:批量</span><br><span class="line">             */</span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),false);</span><br><span class="line">        &#125;;</span><br><span class="line">        // 取消消息的回调</span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;消息消费被中断&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        /**</span><br><span class="line">           * 消费者接收消息</span><br><span class="line">           * 参数详解</span><br><span class="line">                * 1.消费队列</span><br><span class="line">                * 2.消费成功之后是否自动应答 (true:自动应答 false:手动应答&#123;建议使用手动应答&#125;)</span><br><span class="line">                * 3.消费者未成功消费的回调</span><br><span class="line">                * 4.消费者取消消费者的回调</span><br><span class="line">        */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,false,deliverCallback,cancelCallback);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (TimeoutException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应答（手动应答、自动应答）"><a href="#应答（手动应答、自动应答）" class="headerlink" title="应答（手动应答、自动应答）"></a>应答（手动应答、自动应答）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 接收消息的回调</span><br><span class="line">DeliverCallback deliverCallback = (consumerTag, message) -&gt;&#123;</span><br><span class="line">    System.out.println(new String(message.getBody(),&quot;UTF-8&quot;));</span><br><span class="line">    /**</span><br><span class="line">       * 手动应答</span><br><span class="line">       * 参数详解</span><br><span class="line">            * 1.消息的标识 tag</span><br><span class="line">            * 2.是否批量应答  false:不批量 true:批量</span><br><span class="line">    */</span><br><span class="line">    channel.basicAck(message.getEnvelope().getDeliveryTag(),false);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">// 取消消息的回调</span><br><span class="line">CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">    System.out.println(consumerTag + &quot; \n ----消费者取消消息接口回调&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line">   * 消费者接收消息</span><br><span class="line">   * 参数详解</span><br><span class="line">        * 1.消费队列</span><br><span class="line">        * 2.消费成功之后是否自动应答 (true:自动应答 false:手动应答&#123;建议使用手动应答&#125;)</span><br><span class="line">        * 3.消费者未成功消费的回调</span><br><span class="line">        * 4.消费者取消消费者的回调</span><br><span class="line">*/</span><br><span class="line">channel.basicConsume(QUEUE_NAME,false,deliverCallback,cancelCallback);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
          <category> 基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
